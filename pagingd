#!/usr/bin/perl -w

use strict;
use POSIX ();
use Sys::Syslog qw(:standard :macros);
use Proc::Daemon;
use IO::Socket::UNIX qw(SOCK_STREAM);
use IO::Select;
use LWP 5.64;
use URI::Escape;
use Date::Parse;
use Date::Format;
use Hash::Case::Preserve;
use Net::SMTP;
use FreezeThaw qw(freeze thaw);
use lib "/usr/local/bin";
use paging_contacts;

use constant VERSION => '2.1';

# drop root privs to become 'nobody'
$< = $> = 65534 unless ($< == 65534);

# The paging system has both a server (daemon) and client component, both included
# in this file.  External scripts wishing to send a page always call the client.  The
# client checks for the existence of the daemon and, if found, sends it the page.  If
# the daemon isn't running the client forks off a process that becomes the deamon and
# then forwards it the page.  In all cases the daemon stays running the client exits
# after forwarding on the page.
#
# The client can be called with 'nagios' as a parameter and the literal page text on
# stdin.  Or no commandline parameter and an email on stdin.  The email should be
# of the form we get from signalhq.com or answerfirst.com.

# setup globals
my $g_sAppName = 'pagingd';
my $g_sSocketPath = '/tmp/.' . $g_sAppName . '_sock';
my $g_sPIDFile = "/tmp/$g_sAppName.pid";
my %g_hTimerForRoom;	# $g_hTimerForRoom{0} = 300;
my %g_hTicketForRoom;
my $g_bBootOnly = 0;
my $g_tDaemon;
my $g_iDaemonPid;
my @g_aSTDIN;
my %g_hPeoplesRooms;	# $g_hPeoplesRooms{'Rick'} = 0;
my %g_hRoomExpirations;	# $g_hRoomExpirations[0] = time();
my %g_hRoomHistory;
my %g_hPendingNotifies;
my %g_hSilentRecovery;
my %g_hVacationDays;
my %g_hThrottleInfo;    # $g_hThrottleInfo{5555551212} = '4/1231231212';  4 pages in the last 1 minute, since that time
my $g_tListenerSocket;
my $g_iLastOpsEscalationTime = 0;
my $g_iMetricDay = '';
my $g_iMetricCount = 0;

use constant TEST_RUN					=> 0;     # disables pages, ticket creation & mass emails
use constant DEBUG_LEVEL				=> 1;

# install signal handlers
my $tSignalSet = POSIX::SigSet->new();
my $tSignalActionTerm = POSIX::SigAction->new("handler_daemon_exit", $tSignalSet, &POSIX::SA_NODEFER);
#my $tSignalActionHup = POSIX::SigAction->new("handler_clear_rooms", $tSignalSet, &POSIX::SA_NODEFER);
my $tSignalActionHup = POSIX::SigAction->new("handler_sighup", $tSignalSet, &POSIX::SA_NODEFER);
POSIX::sigaction(&POSIX::SIGINT, $tSignalActionTerm);
POSIX::sigaction(&POSIX::SIGTERM, $tSignalActionTerm);
POSIX::sigaction(&POSIX::SIGHUP, $tSignalActionHup);

# open syslog
openlog($g_sAppName, 'ndelay,pid', LOG_LOCAL0);


sub nl($) {
	my $bPrint = shift;
	return (!$bPrint) ? "\n\n" : '';
}



sub pretty_print_number($) {
	my $sPhone = shift;

	if (length($sPhone) == 10) {
		substr($sPhone, 3, 0) = '-';
		substr($sPhone, 7, 0) = '-';
	}

	return $sPhone;
}



sub check_alias_recursion($$);
sub check_alias_recursion($$) {
	my $sAlias = shift;
	my $rhSeenAliases = shift;
	my %hSeenAliases = %{$rhSeenAliases};

	$hSeenAliases{$sAlias} = 1;

	tie my(%hCaselessStaff), 'Hash::Case::Preserve';
	%hCaselessStaff = %hStaff;
			
	while ($hCaselessStaff{$sAlias}{alias} =~ m,(\w+),g) {

		my $sThisAliasValue = $1;
		if (defined $hCaselessStaff{$sThisAliasValue}{alias}) {
			return "$sThisAliasValue recursively used in $sAlias" if (defined $hSeenAliases{$sThisAliasValue});

			my $sResult = check_alias_recursion($sThisAliasValue, \%hSeenAliases);
			return $sResult if $sResult;
		}
	}

	return '';
}



sub boot_syntax_check() {
	my $sAt = $CFGbRequireAtForNames ? '\@' : '\b';
	my $bError = 0;

	foreach my $sGroup (keys %hStaff) {

		# schedule check
		if (defined $hStaff{$sGroup}{schedule}) {

			foreach my $sDate (sort keys %{$hStaff{$sGroup}{schedule}}) {

				if (length($sDate) != 8) {
					print STDERR nl($bError) . " - $sGroup schedule has a date of $sDate: should be 8 digits long (YYYYMMDD)\n";
					$bError = 1;
				}

				if ($hStaff{$sGroup}{schedule}{$sDate} =~ /^auto/) {
					while ($hStaff{$sGroup}{schedule}{$sDate} =~ m,(\w+),g) {
						next if ($1 =~ /^auto$/i);
						my $sSchedPerson = $1;

						my $bFound = 0;
						foreach my $sMember (keys(%{$hStaff{$sGroup}{members}})) {
							if ($sSchedPerson =~ /$sAt($sMember)\b/i) {
								$bFound = 1;
								last;
							}
						}

						unless ($bFound) {
							print STDERR nl($bError) . " - $sGroup auto schedule for $sDate lists $sSchedPerson, which matches no $sGroup member\n" . 
													"      'members' regexs are applied with word boundaries on each end: " . '\b(REGEX)\b' . "\n";
							$bError =1;
						}
                    }
				}
				else {
					my $bFound = 0;
					foreach my $sMember (keys(%{$hStaff{$sGroup}{members}})) {
						if ($hStaff{$sGroup}{schedule}{$sDate} =~ /$sAt($sMember)\b/i) {
							$bFound = 1;
							last;
						}
					}

					unless ($bFound) {
						print STDERR nl($bError) . " - $sGroup schedule for $sDate lists " . $hStaff{$sGroup}{schedule}{$sDate} . ", which matches no $sGroup member\n" .
													"      'members' regexs are applied with word boundaries on each end: " . '\b(REGEX)\b' . "\n";
						$bError =1;
					}
				}
			}
		}

		# member phone check
		if (defined $hStaff{$sGroup}{members}) {
			foreach my $sMember (keys %{$hStaff{$sGroup}{members}}) {

				unless (length($hStaff{$sGroup}{members}{$sMember}) == 10) {
					print STDERR nl($bError) . " - '$sMember' of $sGroup doesn't have a 10 digit phone number\n";
					$bError = 1;
				}
			}
		}

		# escalation check
		if (defined $hStaff{$sGroup}{escalation}) {

			if ((defined $hStaff{$sGroup}{escalation}{timer}) && !(defined $hStaff{$sGroup}{escalation}{on_expire_to})) {
				print STDERR nl($bError) . " - $sGroup has an escalation timer specified but no on_expire_to to escalate to\n";
				$bError = 1;
			}

			if ((!defined $hStaff{$sGroup}{escalation}{timer}) && (defined $hStaff{$sGroup}{escalation}{on_expire_to})) {
				print STDERR nl($bError) . " - $sGroup has an escalation on_expire_to specified but no timer to count down\n";
				$bError = 1;
			}
		}

		# alias check
		if (defined $hStaff{$sGroup}{alias}) {
			my %hNada = ();
			my $sResult =  check_alias_recursion($sGroup, \%hNada);
			if ($sResult) {
				print STDERR nl($bError) . " - Alias: $sResult (danger!)\n";
				$bError = 1;
			}
		}
	}

	# emergency group check
	if (defined($CFGsEmergencyGroup) && !defined($hStaff{$CFGsEmergencyGroup})) {
		print STDERR nl($bError) . ' - $CFGsEmergencyGroup is defined as ' . "$CFGsEmergencyGroup, which doesn't exist\n"; 
		$bError = 1;
	}

	if (defined($CFGsEmergencyGroup) && defined($hStaff{$CFGsEmergencyGroup}) && !defined($hStaff{$CFGsEmergencyGroup}{schedule})) {
		print STDERR nl($bError) . ' - $CFGsEmergencyGroup (' . "$CFGsEmergencyGroup) is lacking a schedule so we won't know who to page\n";
		$bError = 1;
	} 

	if ($bError) {
		print STDERR "\nErrors found - continuing in case this startup is automated (other functionality may still work).\n";
		print STDERR "But these errors should be corrected.  Unpredictable results may follow.\n";
	}
}


sub is_daemon_alive(;$) {
    my $iPID = shift || 0;
    my $bDaemonLives = 0;

    if (!$iPID && -f $g_sPIDFile) {
        if (open(PIDFile, $g_sPIDFile)) {
            $iPID = <PIDFile>;
            close(PIDFile);
        }
	}

    if ($iPID) {
        # normally we'd just do something like: $bDaemonLives = 1 if (kill(0, $iPID));
        # but kill(0) has the restriction that we have to be the same UID as the already
        # running daemon.  and while that would be great, it's not necessarily the case.
        # anyone should be able to invoke us on the command line (as a client).  so we
        # need a different kind of test.
        if (open(STATUS, "/proc/$iPID/status")) {
            my $sStatus = <STATUS>;
            close(STATUS);

            $bDaemonLives = 1 if ((-S $g_sSocketPath) && ($sStatus =~ /Name:\s+(new_)*pagingd/));
        }
    }

	syslog(LOG_DEBUG, "daemon lives = $bDaemonLives, pid from file = $iPID");
    return $bDaemonLives;
}



sub get_members_group($) {
	my $sPerson = shift;

	foreach my $sGroup (keys %hStaff) {
		if (defined $hStaff{$sGroup}{members}) {
			foreach my $sMember (keys %{$hStaff{$sGroup}{members}}) {
				return $sGroup if ($sPerson =~ /$sMember/i);
			}
		}
	}

	return '';
}



sub get_oncall_name($;$) {  # oncall group, followed by optional days to add to the date
    my $sGroup = shift;
    my $iPlusDays = shift || 0;

	return '' unless (defined $hStaff{$sGroup}{schedule});

    my %hSchedule = %{$hStaff{$sGroup}{schedule}};
    my ($iMinute, $iHour, $iDay, $iMonth, $iYear) = (localtime)[1..5];
    my $iToday = sprintf("%d%02d%02d", $iYear+1900, $iMonth+1, $iDay);

    my $sPerson;
    foreach (sort keys %hSchedule) {
        my $iTodayPlus = $iPlusDays ? time2str("%Y%m%d", (str2time(substr($iToday, 0, 8)) + (86400 * $iPlusDays))) : $iToday;

        if ($iTodayPlus >= $_) {

            if ($hSchedule{$_} =~ /^auto/i) {
				my $sThisSched = $hSchedule{$_};
				my @aOnCallNames = ();
				 
				while ($sThisSched =~ m,(\w+),g) {
					next if ($1 =~ /^auto$/i);
					my $sSchedPerson = $1;

					foreach my $sMember (keys(%{$hStaff{$sGroup}{members}})) {
						if ($sSchedPerson =~ /$sMember/i) { 
							push(@aOnCallNames, $sMember);
							last;
						}
					}
				}
				if ($#aOnCallNames < 0) { @aOnCallNames = keys(%{$hStaff{$sGroup}{members}}); }

                my $iDiff = sprintf("%.0f", (((86400 * $iPlusDays) + str2time(substr($iToday, 0, 8)) - str2time(substr($_, 0, 8))) / 86400));
                $sPerson = $aOnCallNames[int($iDiff/7) % ($#aOnCallNames + 1)];
                last;
            }
            else {
                $sPerson = $hSchedule{$_};
            }
        }
        else {
            last;
        }
    }

    $sPerson =~ s/([^|]+).*/$1/;
    return $sPerson;
}



sub get_name_from_number($) {
    my $sNumber = shift;

    return "PI" if ($sNumber eq "9999999999");

    if (length($sNumber) > 9) {
        foreach my $sGroup (keys %hStaff) {

            if (defined $hStaff{$sGroup}{members}) {
                foreach my $sMember (keys %{$hStaff{$sGroup}{members}}) {
                    if ($hStaff{$sGroup}{members}{$sMember} =~ /^$sNumber/) {
                        $sMember =~ s/([^|]+).*/$1/;
                        return $sMember;
                    }
                }
            }
        }
    }

    return $sNumber;
}



sub get_number_from_name($) {
    my $sName = shift;

    foreach my $sGroup (keys %hStaff) {
        if (defined $hStaff{$sGroup}{members}) {
            foreach my $sMember (keys %{$hStaff{$sGroup}{members}}) {
				syslog(LOG_INFO, "get_number_from_name($sName) considering $sMember") if (DEBUG_LEVEL > 4);
                return $hStaff{$sGroup}{members}{$sMember} if ($sName =~ /\b($sMember)\b/i);
            }
        }

    }

    return "";
}



sub daily_housekeeping() {
    my ($iMinute, $iHour, $iDay, $iMonth, $iYear) = (localtime)[1..5];
    my $iToday = sprintf("%d%02d%02d", $iYear+1900, $iMonth+1, $iDay);
	
	unless ($g_iMetricDay eq $iToday) {

		# write the daily total to the metrics log
		if ($g_iMetricDay && open(METRIC_LOG, ">>/tmp/pagingd_metrics.log")) {
			print METRIC_LOG "Total pages sent for $g_iMetricDay were $g_iMetricCount\n"; 
			close(METRIC_LOG);
		}

		$g_iMetricDay = $iToday;
		$g_iMetricCount = 0;

		# decrement any defined vacation days by one - remove completely if zero
		foreach my $sPerson (keys %g_hVacationDays) {
			--$g_hVacationDays{$sPerson};

			if (!$g_hVacationDays{$sPerson}) {
				delete $g_hVacationDays{$sPerson}; 
				send_vacation_email($sPerson, -1);
			}
		}
	}
}


sub handler_sighup() {
    $g_tListenerSocket->shutdown(2);
	$g_tListenerSocket->close();
    unlink($g_sSocketPath)  or syslog(LOG_INFO, "cannot unlink: $!");;
    unlink($g_sPIDFile) or syslog(LOG_INFO, "cannot unlink: $!");
    syslog(LOG_INFO, "Total pages sent for $g_iMetricDay were $g_iMetricCount") if $g_iMetricDay;
    syslog(LOG_DEBUG, "daemon caught SIGHUP (execing $0)");
    closelog();    # syslog
	save_state();
	exec("$0 hup");
	exit;
}



sub handler_daemon_exit() {
	$g_tListenerSocket->shutdown(2);
	$g_tListenerSocket->close();
	unlink($g_sPIDFile);
	unlink($g_sSocketPath);
	syslog(LOG_INFO, "Total pages sent for $g_iMetricDay were $g_iMetricCount") if $g_iMetricDay;
	syslog(LOG_DEBUG, 'daemon exiting on signal');
	closelog();    # syslog
	save_state();
	exit;
}



sub handler_clear_rooms() {
	foreach (keys %g_hPeoplesRooms) {
		delete($g_hPeoplesRooms{$_});
	}

	foreach (keys %g_hRoomExpirations) {
		delete($g_hRoomExpirations{$_});
	}

	foreach (keys %g_hRoomHistory) {
		delete($g_hRoomHistory{$_});
	}

	foreach (keys %g_hPendingNotifies) {
		delete($g_hPendingNotifies{$_});
	}

	foreach (keys %g_hTimerForRoom) {
		delete($g_hTimerForRoom{$_});
	}

	foreach (keys %g_hTicketForRoom) {
		delete($g_hTicketForRoom{$_});
	}
	syslog(LOG_INFO, "Caught SIGHUP: all rooms, timers/escalations, history cleared.");
}



sub delete_room($) {
	my $iRoom = shift;

	delete $g_hRoomExpirations{$iRoom};
	delete $g_hRoomHistory{$iRoom};
	delete $g_hTicketForRoom{$iRoom} if (defined $g_hTicketForRoom{$iRoom});
	delete $g_hTimerForRoom{$iRoom} if (defined $g_hTimerForRoom{$iRoom});
}



sub send_emergency_email($$) {
	my $iTicketNumber = shift;
	my $sMessage = shift;

	my $tSMTP = Net::SMTP->new($CFGsEmergencySMTPServer);
	$tSMTP->mail($CFGsEmergencySMTPFrom);

	if (TEST_RUN) {
		$tSMTP->to($CFGsAdminEmail);
	}
	else {
		my @aRecips = split(/\s*,\s*/, $CFGsEmergencySMTPTo);
		foreach (@aRecips) {
			$tSMTP->to($_);
		}
	}

	$tSMTP->data();
	$tSMTP->datasend("From: <$CFGsEmergencySMTPFrom>\n");
	$tSMTP->datasend("To: $CFGsEmergencySMTPTo\n");
	$tSMTP->datasend("Subject: EMERGENCY CALL\n");
	$tSMTP->datasend("\n");
	$tSMTP->datasend($sMessage);
	$tSMTP->datasend("\n\n----\nThis event is being tracked in RT ticket #$iTicketNumber\n");
	$tSMTP->datasend("$CFGsEmergencyRTLink$iTicketNumber\n");
	$tSMTP->dataend();
	$tSMTP->quit();
}



sub send_vacation_email($$) {
	my $sPerson = shift;
	my $iDays = shift;

	my $tSMTP = Net::SMTP->new($CFGsEmergencySMTPServer);
	$tSMTP->mail($CFGsEmergencySMTPFrom);

	if (TEST_RUN) {
		$tSMTP->to($CFGsAdminEmail);
	}
	else {
		my @aRecips = split(/\s*,\s*/, $CFGsVacationSMTPTo);
		foreach (@aRecips) {
			$tSMTP->to($_);
		}
	}

	$tSMTP->data();
	$tSMTP->datasend("From: <$CFGsEmergencySMTPFrom>\n");
	$tSMTP->datasend("To: $CFGsVacationSMTPTo\n");
	$tSMTP->datasend("Subject: Paging system vacation update\n");
	$tSMTP->datasend("\n");

	if ($iDays > 0) {
		$tSMTP->datasend("$sPerson has just set $iDays day(s) of paging vacation time.\n");
		$tSMTP->datasend("This person will be removed from all on call and group pages.  However you can still\n");
		$tSMTP->datasend("contact them directly by name, if necessary.\n\n");
	}
	elsif ($iDays < 0) {  # vacation time expired
		$tSMTP->datasend("$sPerson\'s configured paging vacation time has elapsed.\n");
		$tSMTP->datasend("This person is now restored to all paging groups.\n\n");
	}
	else {  # vacation time manually canceled
		$tSMTP->datasend("$sPerson has just canceled their configured paging vacation time.\n");
		$tSMTP->datasend("This person is now restored to all paging groups.\n\n");
	}

	$tSMTP->datasend("The paging command '-?' can be used to show everyone that currently has vacation\n");
	$tSMTP->datasend("days set.\n");
	$tSMTP->dataend();
	$tSMTP->quit();
}



sub send_history_email($$) {
	my $sSpeaker = shift;
	my $sAddress = shift;
	my $iRoom = $g_hPeoplesRooms{$sSpeaker};
	
	if ($sAddress =~ /\b([A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4})\b/i) {
		my $sRecipient = $1;
		my $tSMTP = Net::SMTP->new($CFGsEmergencySMTPServer);
		$tSMTP->mail($CFGsEmergencySMTPFrom);
		$tSMTP->to($sRecipient);

		$tSMTP->data();
		$tSMTP->datasend("From: <$CFGsEmergencySMTPFrom>\n");
		$tSMTP->datasend("To: $sRecipient\n");
		$tSMTP->datasend("Subject: Paging system chat history - " . room_status($iRoom) . "\n");
		$tSMTP->datasend("\n");
		$tSMTP->datasend(get_history($iRoom, 1));
		$tSMTP->dataend();
		$tSMTP->quit();
	}
}



sub rt_command($;$) {
	my $sCommand = shift;
	my $sInput = shift || '';
	my $sResult;

	if ($sInput) {
		$sResult = `/bin/echo "$sInput" | $CFGsRTConnectionString $sCommand`;
	}
	else {
		$sResult = `$CFGsRTConnectionString $sCommand`;
	}

	syslog(LOG_DEBUG, "rt_command ($sCommand): $sResult");
	return $sResult;
}



sub sleeping_hours() {
	my ($iMinute, $iHour) = (localtime(time()))[1..2];
	return ($iHour < 8 || $iHour > 21);
}



sub get_history($;$) {
	my $iRoom = shift;
	my $bForEmail = shift || 0;

	if (defined $g_hRoomHistory{$iRoom}) {
		my @aHistory = @{$g_hRoomHistory{$iRoom}};
		return join($bForEmail ? "\n\n" : '; ', @aHistory);
	}

	return '';
}


sub create_911_rt_ticket($) {
	my $sMessage = shift;
	my $iTicketNumber = 0;

    if (rt_command("create -t ticket set queue=$CFGsRTTicketQueue subject=\\'EMERGENCY CALL\\'") =~ /Ticket (\d+) created/) {
    	$iTicketNumber = $1;
    	rt_command("comment -m - $iTicketNumber", $sMessage);
    	syslog(LOG_DEBUG, "RT: created ticket $iTicketNumber");
    }

	return $iTicketNumber;
}



sub handle_paging_commands($$) {
	my $sSpeaker = shift;
	my $sMessage = shift;

	# if the message starts with a colon take it literally;  ignore commands
	return 0 if ($sMessage =~ /^:/);

	# handle ambiguous name references
	my $sAmbiguousReply = '';
	foreach my $sName (keys %hAmbiguousNames) {
		if ($sMessage =~ /\b($sName)\b/i) {
			syslog(LOG_INFO, "Ambiguous name reference ($1) from $sSpeaker");
			$sAmbiguousReply .= "'$1' is ambiguous, try " . $hAmbiguousNames{$sName} . '. ';
		}
	}

	if ($sAmbiguousReply) {
		send_sms_page(get_number_from_name($sSpeaker), '[' . $sAmbiguousReply . "Your message was NOT sent.]");
		return 1;
	}

	# send someone history of your room - pulls them into the room if they're not already
	if ($sMessage =~ /^\+(\w+)/) {
		my $sLateArriver = $1;
		my $sCellPhone = get_number_from_name($sLateArriver);

		if ($sCellPhone =~ /^\d\d/) {
			if (defined $g_hRoomHistory{$g_hPeoplesRooms{$sSpeaker}}) {
				my @aRoomHistory = @{$g_hRoomHistory{$g_hPeoplesRooms{$sSpeaker}}};
				my $iStartIdx = ($#aRoomHistory < 4) ? 0 : $#aRoomHistory - 4;
				syslog(LOG_INFO, "Sending chat history to $sLateArriver from $sSpeaker");
				
				if ($#aRoomHistory > -1) {
					send_sms_page($sCellPhone, "[CHAT HISTORY via $sSpeaker]+");
					for my $iIdx ($iStartIdx .. $#aRoomHistory) {
						send_sms_page($sCellPhone, "+" . $aRoomHistory[$iIdx]);
					}
				}
				my $iMsgCount = $#aRoomHistory - $iStartIdx + 1;
				# send_sms_page(get_number_from_name($sSpeaker), "[Sent $iMsgCount message" . ($iMsgCount == 1 ? '' : 's') . ']');

				# is there an escalation we may need to disarm too?
       			foreach my $iEscalationRoomNumber (keys %g_hTimerForRoom) {
            		if ($g_hPeoplesRooms{$sSpeaker} == $iEscalationRoomNumber) {
    					delete($g_hTimerForRoom{$iEscalationRoomNumber});
						syslog(LOG_INFO, "Deleting escalation timer for room $iEscalationRoomNumber due to chat history reply");
					}
				
				}

			}
			my $sOfficialName = get_name_from_number($sCellPhone);
			process_mentions($sSpeaker, $sMessage);
			process_notifies($sSpeaker, "Chat History: $sSpeaker -> $sOfficialName");
		}
		else {
			send_sms_page(get_number_from_name($sSpeaker), "[I don't have a number for the person you want to send message history to]");
		}
		return 1;
	}

	# email someone history of your room
	if ($sMessage =~ /^\s*>([A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4})\b\s*$/i) {
		send_history_email($sSpeaker, $1);
		send_sms_page(get_number_from_name($sSpeaker), "[Room history emailed to $1]");
		return 1;
	}

	# all rooms status
	if ($sMessage =~ /^\s*=\s*$/) {
		syslog(LOG_INFO, "Sending all room status to $sSpeaker");
		send_sms_page(get_number_from_name($sSpeaker), '[' . room_status(-1) . ']');
		return 1;
	
	}

	# show help
	if ($sMessage =~ /^\s*\?\s*$/) {
		my $sHelp1 = "Silencing\n!x Skip x recoveries\n! Skip all recoveries\n-x Set vacation days\n- Leave room\n!disband Disband room\n\nRT\n~? Get ticket #\n~Txt Unlogged\n~! Stop logging";
		my $sHelp2 = "Status Info\n= All rooms\n-? Vacation\n?? On Call\n?name Define name\n\nMisc\n+Name Send history\n>addy Email history\n:Txt Literal (ignore cmds & names)";

		send_sms_page(get_number_from_name($sSpeaker), $sHelp1);
		send_sms_page(get_number_from_name($sSpeaker), $sHelp2);
		return 1;
	} 

	# show who's on call
	if ($sMessage =~ /^\s*\?\?\s*$/) {
		my $sOnCallMessage = '';
		foreach my $sGroup (keys %hStaff) {
			if (defined $hStaff{$sGroup}{schedule}) {
				$sOnCallMessage .= (length($sOnCallMessage) ? ";\n" : '') . "$sGroup: " . get_oncall_name($sGroup);
			}
		}
		$sOnCallMessage = '[No teams have On Call schedules defined]' unless $sOnCallMessage;
		send_sms_page(get_number_from_name($sSpeaker), "[$sOnCallMessage]");
		return 1;
	} 
 
    # send a group or member definition
    if ($sMessage =~ /^\s*\?\s*(\w+)/) {
        my $sGroup = $1;

        tie my(%hCaselessStaff), 'Hash::Case::Preserve';
        %hCaselessStaff = %hStaff;
        if ((defined $hCaselessStaff{$sGroup}) && (defined $hCaselessStaff{$sGroup}{members})) {
            send_sms_page(get_number_from_name($sSpeaker), "[$sGroup = " . join(', ', sort keys %{$hCaselessStaff{$sGroup}{members}}) . ']');
        }
        elsif ((defined $hCaselessStaff{$sGroup}) && (defined $hCaselessStaff{$sGroup}{alias})) {
            send_sms_page(get_number_from_name($sSpeaker), "[$sGroup = " . $hCaselessStaff{$sGroup}{alias} . ']');
        }
        elsif (my $sNumber = get_number_from_name($sGroup)) {
			send_sms_page(get_number_from_name($sSpeaker), '[' . get_name_from_number($sNumber) . " = " . pretty_print_number($sNumber) . "]"); 
		}
		else {
            send_sms_page(get_number_from_name($sSpeaker), "[There is no defined group or alias called $sGroup]");
        }

		return 1;
    }

	# RT - remove the ticket assocation from a room early (pre-room expiration)
	if ($sMessage =~ /^~\!\s*$/) {
		if (defined $g_hTicketForRoom{$g_hPeoplesRooms{$sSpeaker}}) {
			delete($g_hTicketForRoom{$g_hPeoplesRooms{$sSpeaker}});
			send_sms_page(get_number_from_name($sSpeaker), "[This room is no longer logged to an RT ticket.]");
		}
		else {
            send_sms_page(get_number_from_name($sSpeaker), "[This room has no association to an RT ticket.]");
		}
		return 1;
	}

	# RT - show ticket number
	if ($sMessage =~ /^~\?\s*$/) {
		if (defined $g_hTicketForRoom{$g_hPeoplesRooms{$sSpeaker}}) {
			send_sms_page(get_number_from_name($sSpeaker), "[This room is logging to RT ticket " . $g_hTicketForRoom{$g_hPeoplesRooms{$sSpeaker}} . ".]");
		}
		else {
			send_sms_page(get_number_from_name($sSpeaker), "[This room has no association to an RT ticket.]");
		}
		return 1;
	}

	# remove myself from the room
	if ($sMessage =~ /^\s*-\s*$/) {
		my $bSleepyTime = sleeping_hours();
		my $iSpeakersRoom = $g_hPeoplesRooms{$sSpeaker};
		delete $g_hPeoplesRooms{$sSpeaker};
		syslog(LOG_INFO, "$sSpeaker voluntarily left room $iSpeakersRoom");
		
		my $iPeople = 0;
		my $sLastPersonInRoom = '';
		foreach (keys %g_hPeoplesRooms) {
			if ($g_hPeoplesRooms{$_} == $iSpeakersRoom) {
				next if ($_ eq 'nagios');

				$iPeople++;
				$sLastPersonInRoom = $_;
				send_sms_page(get_number_from_name($_), "[$sSpeaker left the room]") unless $bSleepyTime;
			} 
		}
		send_sms_page(get_number_from_name($sSpeaker), "[You " . ($bSleepyTime ? 'silently ' : '') . "left the room/conversation]");

		# zero or 1 person is left in the room, let's clean it up
		unless ($iPeople > 1) {
			syslog(LOG_INFO, "Cleaning up room $iSpeakersRoom (previously $iPeople occupant(s) remained)");
			delete $g_hPeoplesRooms{$sLastPersonInRoom} if ($iPeople == 1);
			delete_room($iSpeakersRoom);
		}

		return 1;
	}

	# update vacation days
	if ($sMessage =~ /^\s*-\s*(\d+)\s*$/) {
		my $sVacaDays = $1;

		if ($sVacaDays) {
			$g_hVacationDays{$sSpeaker} = $sVacaDays;
		}
		else {
			delete($g_hVacationDays{$sSpeaker});
		}
		syslog(LOG_INFO, "Setting $sVacaDays vacation days for $sSpeaker");
		send_sms_page(get_number_from_name($sSpeaker), ($sVacaDays ? "[Your vacation days are now set to $sVacaDays]" : "[Your vacation settings have been removed]"));
		send_vacation_email($sSpeaker, $sVacaDays);

		return 1;
	}

	# show vacation days
	if ($sMessage =~ /^\s*-\s*\?$/) {
		my $sVacations = vacation_status();
		send_sms_page(get_number_from_name($sSpeaker), $sVacations ? $sVacations : "[No one currently has vacation time configured]");

		return 1;
	}

	# silence recovery pages
	if ($sMessage =~ /^\s*\!\s*(\d*)$/) {
		if ($1 > 0) {
			$g_hSilentRecovery{$sSpeaker} = $1;
			syslog(LOG_INFO, "Silencing $1 RECOVERY page(s) for $sSpeaker");
			send_sms_page(get_number_from_name($sSpeaker), "[The next $1 recovery page" . ($1 > 1 ? 's are' : ' is') .  " now silenced for you]");
		}
		elsif (($1 eq '0') || (defined $g_hSilentRecovery{$sSpeaker})) {
			delete($g_hSilentRecovery{$sSpeaker});
			syslog(LOG_INFO, "Restoring RECOVERY pages for $sSpeaker");
			send_sms_page(get_number_from_name($sSpeaker), "[Recovery pages are now restored for you]");
		}
		else {
			$g_hSilentRecovery{$sSpeaker} = -1;
			syslog(LOG_INFO, "Silencing RECOVERY pages for $sSpeaker");
			send_sms_page(get_number_from_name($sSpeaker), "[Recovery pages are now silenced for you]");
		}

		return 1;
	}

	# disband room
	if ($sMessage =~ /^\s*\!disband\s*$/i) {
        my $bSleepyTime = sleeping_hours();
        my $iSpeakersRoom = $g_hPeoplesRooms{$sSpeaker};
        delete $g_hPeoplesRooms{$sSpeaker};
        syslog(LOG_INFO, "$sSpeaker disbanded room $iSpeakersRoom");

        foreach (keys %g_hPeoplesRooms) {
            if ($g_hPeoplesRooms{$_} == $iSpeakersRoom) {
        		delete $g_hPeoplesRooms{$_};
                next if ($_ eq 'nagios');

                send_sms_page(get_number_from_name($_), "[$sSpeaker has disbanded the room]") unless $bSleepyTime;
            } 
        }

        send_sms_page(get_number_from_name($sSpeaker), "[You " . ($bSleepyTime ? 'silently ' : '') . "disbanded the room]");
        syslog(LOG_INFO, "Cleaning up room $iSpeakersRoom");
        delete_room($iSpeakersRoom);

        return 1;
	}

	if ($sMessage =~ /^[-:+?=~!]/) {
		send_sms_page(get_number_from_name($sSpeaker), "[Invalid command]");
		return 1;
	}

	return 0;
}


sub get_a_room() {
	my $iEmptyRoom = -1;
	while (defined $g_hRoomExpirations{++$iEmptyRoom}) { 1; }
	return $iEmptyRoom;
}



sub combine_rooms($$) {		# ('Rick', 'Sean') i.e. Rick mentions Sean and wants to pull him in
	my $sSpeaker = shift;	# can be a person's name or room number
	my $sMention = shift;
	my $iDestinationRoom;

	# were we given a room number instead of a speaker name?
	if ($sSpeaker =~ /^\d+/) {
		$iDestinationRoom = $sSpeaker;
	}
	else {
		# where are we moving people TO?
		if (defined $g_hPeoplesRooms{$sSpeaker}) {
			$iDestinationRoom = $g_hPeoplesRooms{$sSpeaker};
		}
		else {
			# the speaker wasn't in a room at all - find an empty one to stick them in
			$iDestinationRoom = $g_hPeoplesRooms{$sSpeaker} = get_a_room();
		}
	}

	syslog(LOG_DEBUG, "combine_rooms($sSpeaker, $sMention): dest=$iDestinationRoom") if (DEBUG_LEVEL > 1);

	# let's figure out where the mentioned person is
	# if they're already in the right room, it's a no-op
	return if (defined $g_hPeoplesRooms{$sMention} && ($g_hPeoplesRooms{$sMention} == $iDestinationRoom));	

	# are they part of an existing conversation with other people? (i.e. in a different room)
	if (defined $g_hPeoplesRooms{$sMention}) {
		my $iSourceRoom = $g_hPeoplesRooms{$sMention};

		# if so then we have to move every person that was in that other room with them
		foreach my $sPerson (keys %g_hPeoplesRooms) {
			if ($g_hPeoplesRooms{$sPerson} == $iSourceRoom) {
				$g_hPeoplesRooms{$sPerson} = $iDestinationRoom;
				syslog(LOG_DEBUG, " - combine_rooms, dragging $sPerson to $iDestinationRoom") if (DEBUG_LEVEL > 1);
			}
		}

		# iSourceRoom is now empty; let's get rid of it
		syslog(LOG_DEBUG, " - combine_rooms, room $iSourceRoom is empty;  deleting");
		delete_room($iSourceRoom);
	}
	else {
		syslog(LOG_DEBUG, " - combine_rooms, basic add to $iDestinationRoom") if (DEBUG_LEVEL > 1);
		# they weren't already part of a conversation so let's just add them to
		# the correct room and note that they need to be notified of a room entry
		$g_hPeoplesRooms{$sMention} = $iDestinationRoom;
	}

	# everyone that's now in the destination room --whether we just pulled them in or they
	# were previously there-- needs to be notified of who's been added
	foreach my $sPerson (keys %g_hPeoplesRooms) {
		$g_hPendingNotifies{$sPerson} = 1 if ($g_hPeoplesRooms{$sPerson} == $iDestinationRoom);
	}
}


sub process_mentions($$);
sub process_mentions($$) {
	my $sSpeaker = shift;
	my $sMessage = shift;
	my $sAt = $CFGbRequireAtForNames ? '\@' : '\b';

	foreach my $sGroup (keys %hStaff) {

		# look for any alias mentions
		if (defined($hStaff{$sGroup}{alias}) && ($sMessage =~ /$sAt($sGroup)\b/i)) {
			my $sOrigMsg = $sMessage;
			my $sAlias = $hStaff{$sGroup}{alias};

			if ($sAlias !~ /$sAt($sGroup)\b/i) {
				$sMessage =~ s/$sAt($sGroup)\b/$sAlias/gi;
				syslog(LOG_DEBUG, "mention found (alias): $sGroup - interpolating");
				process_mentions($sSpeaker, $sMessage);
				$sMessage = $sOrigMsg;
			}
			else {
				syslog(LOG_INFO, "Self-referencing alias found ($sAlias); ignoring");
			}
		}

		next unless defined($hStaff{$sGroup}{members});

		# look for any group mentions - we have to loop through them one by one in case multiple are mentioned
		if ($sMessage =~ /$sAt($sGroup)\b/i) {
			syslog(LOG_DEBUG, "mention found (group): $sGroup");

			# for any group mention we have to process each person in the group
			foreach my $sPerson (keys %{$hStaff{$sGroup}{members}}) {
				$sPerson =~ s/([^|]+).*/$1/;

				unless (defined $g_hVacationDays{$sPerson}) {
					# for each group member we want to see if they're in an existing room/conversation & if so
					# pull *everyone* from that room (the group member & everyone they're talking to) into the
					# original sSpeaker's room
					combine_rooms($sSpeaker, $sPerson);
				}
				else {
					syslog(LOG_INFO, "excluding $sPerson from $sGroup due to vacation - " . $g_hVacationDays{$sPerson});
				}
			}
		}

		# look for name mentions - we have to loop through them one by one in case multiple are mentioned
		foreach my $sPerson (keys %{$hStaff{$sGroup}{members}}) {
			if ($sMessage =~ /$sAt($sPerson)\b/i) {
				syslog(LOG_DEBUG, "mention found (member): $sPerson");
				$sPerson =~ s/([^|]+).*/$1/;
				combine_rooms($sSpeaker, $sPerson);
			}
		}

		# look for escalation tag mentions
		if (defined $hStaff{$sGroup}{escalation}{tag}) {
			my $sTag = $hStaff{$sGroup}{escalation}{tag};

			if ($sMessage =~ /$sAt($sTag)\b/i) {
				my $iCount = 0;
				my $sOnCallPerson;

				# if a tag results in an oncall person that's on vacation, let's try
				# two more times, moving the oncall schedule out a week each time
				# if the same person is configured on call for 3 weeks in a row (while
				# on vacation), well, they're going to get the page anyway
				do {
					$sOnCallPerson = get_oncall_name($sGroup, $iCount * 7);
				} while (defined($g_hVacationDays{$sOnCallPerson}) && ++$iCount < 3);

				syslog(LOG_DEBUG, "mention found (tag): $sTag [->$sOnCallPerson]");
				combine_rooms($sSpeaker, $sOnCallPerson);
			}
		}
	}
}



sub room_status(;$) {
	my $iTargetRoom = shift; 
	my $sFullResult = '';

	foreach my $iRoom (sort keys %g_hRoomExpirations) {
		next if ($iTargetRoom > -1 && ($iRoom != $iTargetRoom));

		my %hRemovedFromGroup;
		my %hThisRoomByGroup;

		my $sThisRoom = '';
		foreach my $sPerson (sort keys %g_hPeoplesRooms) {
			if (($g_hPeoplesRooms{$sPerson} == $iRoom) && ($sPerson ne 'nagios')) {
				$sThisRoom .= (length($sThisRoom) ? ', ' : '') . $sPerson;

				my $sThisPersonsGroup = get_members_group($sPerson);
				$hRemovedFromGroup{$sThisPersonsGroup}++;
				$hThisRoomByGroup{$sThisPersonsGroup}{$sPerson} = 1;
			}
		}

		my @aRoomOccupants = ();
		foreach my $sGroup (keys %hThisRoomByGroup) {
			if ($hRemovedFromGroup{$sGroup} == keys %{$hStaff{$sGroup}{members}}) {
				push(@aRoomOccupants, $sGroup);
			}
			else {
				foreach my $sPerson (keys %{$hThisRoomByGroup{$sGroup}}) {
					push(@aRoomOccupants, $sPerson);
				}
			}
		}

		$sFullResult .= (length($sFullResult) ? "\n" : '') . ($iTargetRoom > -1 ? '' : "Room $iRoom: ") . join(', ', sort @aRoomOccupants);
	}

	return (length($sFullResult) ? $sFullResult : 'no rooms / no conversations');
}



sub save_state() {
	my $SilentState = freeze(%g_hSilentRecovery);
	my $VacaState = freeze(%g_hVacationDays);
	if (open(STATE, ">/tmp/$g_sAppName.state")) {
		print STATE $SilentState . "\n";
		print STATE $VacaState . "\n";
		print STATE $g_iMetricDay . "\n";
		print STATE $g_iMetricCount . "\n";
		close(STATE);
	}
}



sub restore_state() {
	if (open(STATE, "/tmp/$g_sAppName.state")) {
		my $SilentState = <STATE>;
		my $VacaState = <STATE>;
		my $MetricDay = <STATE>;
		my $MetricCount = <STATE>;
		close(STATE);
		chomp($SilentState);
		chomp($VacaState);
		chomp($MetricDay);
		chomp($MetricCount);
		%g_hSilentRecovery = thaw($SilentState);
		%g_hVacationDays = thaw($VacaState);
		$g_iMetricDay = $MetricDay;
		$g_iMetricCount = $MetricCount;
	}
}



sub silence_status() {
	my $sResult = '';

	foreach my $sPerson (sort keys %g_hSilentRecovery) {
		$sResult .= (length($sResult) ? ', ' : '') . "$sPerson: " . $g_hSilentRecovery{$sPerson};
	}

	return $sResult;
}



sub vacation_status() {
	my $sResult = '';

	foreach my $sPerson (sort keys %g_hVacationDays) {
		$sResult .= (length($sResult) ? ",\n" : '') . "$sPerson: " . $g_hVacationDays{$sPerson};
	}

	return (length($sResult) ? "Vaca Days:\n$sResult" : "");
}



sub strip_hidden_aliases($) {
	my $sMessage = shift;
	my $sAt = $CFGbRequireAtForNames ? '\@' : '\b';

	foreach my $sGroup (keys %hStaff) {

		if (defined($hStaff{$sGroup}{alias}) && defined($hStaff{$sGroup}{hidden}) && ($sMessage =~ /$sAt($sGroup)\b/i)) {
			$sMessage =~ s/$sAt($sGroup)\b//gi;
			syslog(LOG_INFO, "redacting hidden alias $sGroup");
		}
	}

	return $sMessage;
}



sub expire_rooms() {
	my $iNow = time();

	foreach my $iRoom (keys %g_hRoomExpirations) {

		# find expired rooms
		if ($g_hRoomExpirations{$iRoom} < $iNow) {
			syslog(LOG_INFO, "expiring room $iRoom");

			delete_room($iRoom);

			# find everyone in the expired room and kick them out
			foreach my $sPerson (keys %g_hPeoplesRooms) {
				if ($g_hPeoplesRooms{$sPerson} == $iRoom) {
					delete $g_hPeoplesRooms{$sPerson};
				}
			}
			
		}
	}
}



sub send_sms_page($$) {
	my $iCellNumber = shift;
	my $sMessage = shift;
	my $tBrowser = LWP::UserAgent->new;
	my $iNow = time();
	use constant THROTTLE_PAGES => 5;

	unless ($iCellNumber) {
		syslog(LOG_INFO, "Skipping send to blank recipient (no cell number)");
		return;
	}

	$sMessage = substr($sMessage, 0, 160);

	if ($sMessage =~ /^(PROBLEM|RECOVERY)/) {

		if ((defined $g_hThrottleInfo{$iCellNumber}) && ($g_hThrottleInfo{$iCellNumber} =~ /(\d+)\/(\d+)/)) {
			my $iCount = $1;
			my $iLastTime = $2;

			if ($iNow - $iLastTime > 60) {
				$g_hThrottleInfo{$iCellNumber} = '1/' . $iNow;
			}
			else {
				$g_hThrottleInfo{$iCellNumber} = $iCount+1 . '/' . $iNow;

				if ($iCount > THROTTLE_PAGES - 1) {
					syslog(LOG_INFO, "PAGE THROTTLED ($iCellNumber): $sMessage");
					return;
				}
				elsif ($iCount == THROTTLE_PAGES - 1) {
					$sMessage = 'Throttled::' . $sMessage;
				}
			}
		}
		else {
			$g_hThrottleInfo{$iCellNumber} = '1/' . $iNow;
		}
	}

	if (TEST_RUN) {
		syslog(LOG_INFO, "FAKE PAGE ($iCellNumber): $sMessage");
		return;
	}

	# here we do an HTTP POST to signalhq.com, our vendor that lets us bypass cell companies'
	# spam filters to get our SMS messages to cell phones
	$tBrowser->timeout(10);
	my $tResponse = $tBrowser->post('http://app.signalhq.com/messages/send_individual_message',
		[
			'a' => '171',
			'c' => '3863',
			'm' => $sMessage,
			'mdn' => $iCellNumber,
		]);
	syslog(LOG_INFO, "PAGE [" . $tResponse->is_success . "] ($iCellNumber): $sMessage");
	++$g_iMetricCount;

	unless ($tResponse->is_success) {
		if (open(MAIL, '| /usr/sbin/sendmail 6172939795@txt.att.net')) {
#		if (open(MAIL, '| /usr/sbin/sendmail 6178522182@txt.att.net')) {
			print MAIL "pagingd can't send via signalhq.com!";
			close(MAIL);
		}
	}
}



sub process_notifies($;$) {
	my $sSpeaker = shift;  		# can be a person's name or room number
	my $sExtraMessage = shift;
	my $bSilentMode = 0;

	if ((defined $sExtraMessage) && ($sExtraMessage eq '*')) {
		undef($sExtraMessage);
		$bSilentMode = 1;
	}

	# figure out who's in the room with the speaker
	my $sAudience = room_status(($sSpeaker =~ /^\d+/) ? $sSpeaker : $g_hPeoplesRooms{$sSpeaker});

	# tell everyone in the notify list who's in the room
	foreach my $sPerson (keys %g_hPendingNotifies) {
		delete $g_hPendingNotifies{$sPerson};
		next if ($sPerson eq 'nagios');

		send_sms_page(get_number_from_name($sPerson), "[Audience is now $sAudience]" . ((defined $sExtraMessage) ? " $sExtraMessage" : ''))
			unless ($bSilentMode && (defined $g_hSilentRecovery{$sPerson}));
	}
}



sub process_pages($$) {
	my $sSpeaker = shift;	# can be a person or a room number
	my $sMessage = shift;
	my $iRoom = ($sSpeaker =~ /^\d+/) ? $sSpeaker : $g_hPeoplesRooms{$sSpeaker};
	my $iRecips = 0;

	if ($iRoom =~ /^\d+/ || $sSpeaker eq 'emergency') {
		$iRoom = $g_hPeoplesRooms{get_oncall_name($CFGsEmergencyGroup)} if ($sSpeaker eq 'emergency');

		foreach my $sPerson (keys %g_hPeoplesRooms) {
			next if (($sPerson eq 'nagios') || ($sPerson eq 'emergency') || ($sPerson eq 'web1') || ($sPerson eq 'web2'));

			if ($g_hPeoplesRooms{$sPerson} == $iRoom) {
				next if ($sPerson eq $sSpeaker);
				++$iRecips;

				if (($sMessage =~ /^RECOVERY/) && (defined $g_hSilentRecovery{$sPerson})) {
					# we don't decrement if it's set to -1 as that's a permanent setting
					$g_hSilentRecovery{$sPerson}-- if ($g_hSilentRecovery{$sPerson} > 0);
					syslog(LOG_DEBUG, "process_page($sSpeaker,x): Silenced RECOVERY for $sPerson (remaining " . $g_hSilentRecovery{$sPerson} . ")");
				}
				else {
					send_sms_page(get_number_from_name($sPerson), $sMessage)
				}
			}
		}
	}

	my $bHandled = 0;

	if ($sSpeaker && ($sSpeaker ne 'nagios') && ($sSpeaker ne 'emergency')) {
    	# loop through all rooms with escalation timers on them
    	foreach my $iEscalationRoomNumber (keys %g_hTimerForRoom) {

    		# if the reply is from the person in this escalation room
    		# (probably the on call person probably saying "I got it!")
    		if ($g_hPeoplesRooms{$sSpeaker} == $iEscalationRoomNumber) {
    			syslog(LOG_INFO, "Escalation canceled due to reply from $sSpeaker (room $iEscalationRoomNumber)");
    			delete($g_hTimerForRoom{$iEscalationRoomNumber});

				my $sSpeakersGroup = get_members_group($sSpeaker);
				if (defined $hStaff{$sSpeakersGroup}{escalation}{cancel_msg}) {
    				send_sms_page(get_number_from_name($sSpeaker), $hStaff{$sSpeakersGroup}{escalation}{cancel_msg});
				}

    			$bHandled = 1;
    			last;
    		}
    	}
	}

	# if no pages were sent out and the reply isn't from a person in an escalation timer room
	if (!$iRecips && !$bHandled) {
			if ($sSpeaker eq 'nagios') {
				syslog(LOG_INFO, "nagios sent a message with no recipients;  page ignored");
			}
			else {
				send_sms_page(get_number_from_name($sSpeaker), 
					"[There's no one in this conversation other than you.  Name a person or group to include someone else.]");
			}
	}
}



sub daemon_startup() {
	$g_tDaemon = Proc::Daemon->new(
		work_dir => '/tmp',
		pid_file => $g_sPIDFile,
	);

	$g_iDaemonPid = $g_tDaemon->Init;
	daemon_main() unless $g_iDaemonPid;
	# else we're in the client and just return from here
}


sub daemon_main() {
	syslog(LOG_INFO, 'daemon starting in ' . (TEST_RUN ? 'TEST MODE - no pages will be sent' : 'live mode'));
	unlink($g_sSocketPath);
	restore_state();

	# open the main server-side listening socket
	$g_tListenerSocket = IO::Socket::UNIX->new(
		Type   => SOCK_STREAM,
		Local  => $g_sSocketPath,
		Listen => 50,
	) or die("Can't create server socket: $!\n");

	# create a list of file handles for reading, add our listening socket 
	my ($tReadHandles) = new IO::Select();
	$tReadHandles->add($g_tListenerSocket);

	# the life of a daemon - listen for socket connections all day
	while (1) {

		# sleep at most 30 seconds waiting for a socket connection
		my ($tReadSet) = IO::Select->select($tReadHandles, undef, undef, 30);
		expire_rooms();
		daily_housekeeping();

		# see if we woke up for a socket vs the 30 second timeout
		foreach my $tRH (@$tReadSet) {
			my $tSocket = $g_tListenerSocket->accept() or die("Can't accept connection: $!\n");
			my $sSenderCallerId = '';
			my $sMessage = '';
			my $sSpeaker = '';

			while (my $sLine = <$tSocket>) {
				chomp($sLine);

				if ($sLine =~ /FF:(\S+):FF/) {
					$sSenderCallerId = $1;

					$sSpeaker = get_name_from_number($sSenderCallerId);
					syslog(LOG_DEBUG, "speaker = $sSpeaker");
					next;
				}

				$sMessage .= (length($sMessage) ? "\n" : '') . $sLine;
			}

			if ($sSpeaker =~ /^\d/) {
				syslog(LOG_INFO, "Page from unknown user ($sSpeaker);  dropping");
			}
			else {
				my $sCompressedMessage = $sMessage;
				$sCompressedMessage =~ s/\n//g;
				unless (handle_paging_commands($sSpeaker, $sCompressedMessage)) {
					my $sSilenceStatus = silence_status();
					my $sVacationStatus = vacation_status();
					syslog(LOG_DEBUG, "MSG: $sMessage");
					syslog(LOG_DEBUG, "CSG: $sCompressedMessage") if (DEBUG_LEVEL);
					syslog(LOG_DEBUG, "PRE: " . room_status(-1)) if (DEBUG_LEVEL > 1);
					syslog(LOG_DEBUG, "Silenced RECOVERY set: $sSilenceStatus") if ($sSilenceStatus);
					syslog(LOG_DEBUG, "Vacation days set: $sVacationStatus") if ($sVacationStatus);

					# process all group/name mentions for non emergency pages
					# (also puts the speaker in a room if they don't already have one)
					if ($sSpeaker ne 'emergency') {

						# leading colon means we take the message literally;  don't look for name references
						if ($sMessage =~ /^:/) {
							$sMessage =~ s/^://;
						}
						else {
							process_mentions($sSpeaker, $sMessage);
							$sMessage = strip_hidden_aliases($sMessage);
						}
					}
					else {
						# emergency page - put the On Call person in a room and set a timer for their reply
						my $iEmergencyRoom;
						my $sOnCallPerson = get_oncall_name($CFGsEmergencyGroup);
						if (defined $g_hPeoplesRooms{$sOnCallPerson}) {
							$iEmergencyRoom = $g_hPeoplesRooms{$sOnCallPerson};
						}
						else {
							$g_hPeoplesRooms{$sOnCallPerson} = $iEmergencyRoom = get_a_room();
						}
						my $iEscTime = defined($hStaff{$CFGsEmergencyGroup}{escalation}{timer}) ? $hStaff{$CFGsEmergencyGroup}{escalation}{timer} : 60;
						$g_hTimerForRoom{$iEmergencyRoom} = time() + $iEscTime - 1;

						my @aHistory = ($sMessage);
						$g_hRoomHistory{$iEmergencyRoom} = \@aHistory;
						syslog(LOG_DEBUG, "Setting Emergency escalation timer on room $iEmergencyRoom to " . $g_hTimerForRoom{$iEmergencyRoom});

						my $iTicketNumber = TEST_RUN ? 40314 : create_911_rt_ticket($sMessage);
						send_emergency_email($iTicketNumber, $sMessage) unless TEST_RUN;  
						$g_hTicketForRoom{$iEmergencyRoom} = $iTicketNumber;
					}

					# if the page is from nagios and it didn't result in any notifications (i.e. it didn't mention
					# any recipients by name or group), then it's destined for nowhere;  we can bail.
					if (($sSpeaker eq 'nagios' ) && !defined($g_hPeoplesRooms{'nagios'})) { 
						syslog(LOG_INFO, "nagios sent a message with no recipients; page ignored");
					}
					else {
						# below we setup room details, including expiriation time & history
						# we don't want to do this unless there's a conversation in progress
						if (defined $g_hPeoplesRooms{$sSpeaker} || $sSpeaker eq 'emergency' || $sSpeaker eq 'nagios') {
							my $bSkipNotifies = 0;

							my $sEscalationTags = '';
							foreach my $sGroup (keys %hStaff) {
								$sEscalationTags .= (length($sEscalationTags) ? '|' : '') . $hStaff{$sGroup}{escalation}{tag} if (defined $hStaff{$sGroup}{escalation}{tag});
							}
							my $sAt = $CFGbRequireAtForNames ? '\@' : '\b';

							# special case:  if nagios pages oncall AND the oncall person isn't already in a room
							# with someone else, then set an escalation timer for their room
							if (($sSpeaker eq 'nagios') && ($sMessage =~ /$sAt($sEscalationTags)\b/i)) {
								my $iParticipants = 0;
								foreach my $iTestRoom (values %g_hPeoplesRooms) {
									$iParticipants++ if ($iTestRoom == $g_hPeoplesRooms{'nagios'});
									last if ($iParticipants > 2);
								}

								# consider setting an escalation timer if the room only has the on call person & nagios
								unless ($iParticipants > 2) {

									if ($sMessage !~ /^RECOVERY/) {
										# nagios may send a second copy of the PROBLEM page before we've escalated
										# and we don't want that to reset our escalation timer.  so check if a timer
										# was previously set before setting a new one
										if (!defined $g_hTimerForRoom{$g_hPeoplesRooms{'nagios'}}) {

											foreach my $sStaffGroup (keys %hStaff) {
												if (defined $hStaff{$sStaffGroup}{escalation} && defined $hStaff{$sStaffGroup}{escalation}{tag}) {
													my $sTag = $hStaff{$sStaffGroup}{escalation}{tag};

													if ($sMessage =~ /$sTag/i) {
														$bSkipNotifies = 1;
														$sMessage = '+' . $sMessage;
														$g_hTimerForRoom{$g_hPeoplesRooms{'nagios'}} = time() + $hStaff{$sStaffGroup}{escalation}{timer} - 1;
														syslog(LOG_INFO, 'Setting escalation timer on room ' . $g_hPeoplesRooms{'nagios'} . ' to ' . $g_hTimerForRoom{$g_hPeoplesRooms{'nagios'}});
													}
												}
											}
										}
									}
									# Else this is a recovery page;  but is there an escalaltion timer in effect?
									elsif (defined $g_hTimerForRoom{$g_hPeoplesRooms{'nagios'}}) {  
										$sMessage = '-' . $sMessage;
										delete($g_hTimerForRoom{$g_hPeoplesRooms{'nagios'}});
										syslog(LOG_INFO, 'Escalation canceled due to RECOVERY page (room ' . $g_hPeoplesRooms{'nagios'} . ')');
										$bSkipNotifies = 1;
									}
									else {
										# recovery page has come through but there's no escalation timer going.  so we'll
										# just send out this recovery as usual.  but let's nix the audience update.
										# this is safe becauase nagios isn't likely to be changing the audience between problem
										# & recovery.  so either the audience didn't change anyway (nothing to notify) or we're
										# going from a non-existent chat room to one being created just for this recovery message.
										# either way, we can skip this update.
										$bSkipNotifies = 1;
									}
								}
							}

							# set/update the expiration time on the [possibly newly created] room
							$g_hRoomExpirations{$g_hPeoplesRooms{($sSpeaker eq 'emergency') ? get_oncall_name($CFGsEmergencyGroup) : $sSpeaker}} = time() + 5400;    # 90 minutes from now

							my $sOrigMessage = $sMessage;
							$sMessage = "$sSpeaker: $sMessage" unless (($sSpeaker eq 'nagios') || ($sSpeaker eq 'emergency'));

							# add the message to the room's history array
							if (defined $g_hPeoplesRooms{$sSpeaker}) { 	 # always true except for an emergency message
								if (defined $g_hRoomHistory{$g_hPeoplesRooms{$sSpeaker}}) {
									push(@{$g_hRoomHistory{$g_hPeoplesRooms{$sSpeaker}}}, $sMessage);
								}
								else {
									my @aHistory = ($sMessage);
									$g_hRoomHistory{$g_hPeoplesRooms{$sSpeaker}} = \@aHistory;
								}
							}

							syslog(LOG_DEBUG, "Ticket for room " . $g_hPeoplesRooms{$sSpeaker} . ": " . $g_hTicketForRoom{$g_hPeoplesRooms{$sSpeaker}}) if (defined $g_hTicketForRoom{$g_hPeoplesRooms{$sSpeaker}});
							rt_command("comment -m - " . $g_hTicketForRoom{$g_hPeoplesRooms{$sSpeaker}}, $sMessage)
								if ((defined $g_hTicketForRoom{$g_hPeoplesRooms{$sSpeaker}}) && ($sOrigMessage !~ /^~/));

							syslog(LOG_DEBUG, "POST: " . room_status(-1)) if (DEBUG_LEVEL > 1);
							syslog(LOG_INFO, "Notify: " . join(', ', sort keys(%g_hPendingNotifies)));

							foreach my $iRoom (keys %g_hRoomExpirations) {
								syslog(LOG_DEBUG, "Room $iRoom history: " . get_history($iRoom)) if (DEBUG_LEVEL > 1);
							}

							foreach my $iRoom (keys %g_hTicketForRoom) {
								syslog(LOG_DEBUG, "Ticket for room $iRoom: " . $g_hTicketForRoom{$iRoom}) if (DEBUG_LEVEL > 1);
							}

							process_pages($sSpeaker, $sMessage);

							if (!$bSkipNotifies) {
								if ($sMessage =~ /^RECOVERY/) {
									process_notifies($sSpeaker, '*'); 
								}
								else {
									process_notifies($sSpeaker); 
								}
							}
							else {
								# we still have to delete the pending notifications
								foreach my $sPerson (keys %g_hPendingNotifies) {
									delete $g_hPendingNotifies{$sPerson};
								}
							}

							foreach my $sPerson (keys %g_hSilentRecovery) {
								if ($g_hSilentRecovery{$sPerson} == 0) {
									delete($g_hSilentRecovery{$sPerson}); 
									syslog(LOG_INFO, "Silent request count reached for $sPerson;  restoring RECOVERY pages");
								}
							}
						}
						else {
							send_sms_page(get_number_from_name($sSpeaker),
                    			"[There's no one in this conversation other than you.  Name a person or group to include someone else.]");
						}
					}
				}
			}
			close($tSocket);
		}

		# the daemon hits this loop at least every 30 seconds - sooner if there's a socket connection
		# let's check to see if we have a room timer that's expiring and we need to escalate a page
		# this is one area where we don't have a $sSpeaker
		foreach my $iEscalationRoomNumber (keys %g_hTimerForRoom) {
			next unless ($g_hTimerForRoom{$iEscalationRoomNumber} < time());

			syslog(LOG_INFO, "Escalation timer expired for room $iEscalationRoomNumber - ESCALATING");

			foreach my $sPerson (keys %g_hPeoplesRooms) {

				if (($g_hPeoplesRooms{$sPerson} == $iEscalationRoomNumber)
					 && ($sPerson ne 'nagios') && ($sPerson ne 'emergency')) {

					# then we're going to escalate 
					my $sPersonsGroup = get_members_group($sPerson);

					if (defined $hStaff{$sPersonsGroup}{escalation}{on_expire_to}) {
						process_mentions($sPerson, $hStaff{$sPersonsGroup}{escalation}{on_expire_to});
					}
					else {
						syslog(LOG_INFO, "Escalation timer expired but there's no 'on_expire_to' list to escalate to;  ignoring");
					}

					last;
				}
			}

			# then send everything out
			if (defined $g_hRoomHistory{$iEscalationRoomNumber}) {
				my @aHistory = @{$g_hRoomHistory{$iEscalationRoomNumber}};
				process_pages($iEscalationRoomNumber, $aHistory[$#aHistory]);
			}
			else {
				process_pages($iEscalationRoomNumber, "[An emergency page has been escalated to you but the original text is missing.  Check your email.]");
			}

			process_notifies($iEscalationRoomNumber, 'Was auto escalated');
			delete($g_hTimerForRoom{$iEscalationRoomNumber});
		}
	}

	exit;
}



sub parse_email_from_stdin() {
	my @aNewMsg;
	my $sClientCallerId = '';
	my $bInMessageBody = 0;
	my $bEmergencyEmail = 0;
	my $bQuotedPrintable = 0;

	foreach (@g_aSTDIN) {
		#syslog(LOG_DEBUG, "raw_message_line: " . $_);

		# snag & save the sender's callerid from the subject line
		if (/^Subject: sms_reply:(\d+)/) {
			$sClientCallerId = $1;
		}
		elsif (/^Subject: NPR - ER ISSUES/) {
			$bEmergencyEmail = 1;
		}

		if (/^Content-Transfer-Encoding:\s+quoted-printable/i) {
			$bQuotedPrintable = 1;
		}

		# cheap and hackishly use the callerid field to store the sender's name
		# if the input is from an email reply rather than an sms one
		if (/^From: (\S+)/ && !length($sClientCallerId)) {
			$sClientCallerId = $1;
		}

		# look for a blank line, separating headers & body
		if (/^$/) {

			# if the sender is valid and we've hit a blank line then
			# the rest of the input is valid message text
			if (length($sClientCallerId)) {
				$bInMessageBody = 1;
			}
			else {
				return 0;
			}

			next;    # skip the blank line
		}

		if ($bInMessageBody) {
			if ($bQuotedPrintable) {
				s/=(\n*)$/$1/; 
				s/=3D/=/g;
			}

			s/\&apos;/\'/g;
			push(@aNewMsg, $_);
		}
	}

	@g_aSTDIN = @aNewMsg;

	if ($bEmergencyEmail) {
		foreach (@g_aSTDIN) {
			s/^\s*(\w|\s)+:\s*(.+)/$2/;	# drop the field names
		}
		$sClientCallerId = 'emergency';
	}


	return $sClientCallerId;
}


#-#  M A I N  #-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#

boot_syntax_check();

my $sClientCallerId = '';

if (-t STDIN) {  # no stdin
	#print "The paging app can be called in one of two ways:\n";
	#print "\t1. 'nagios' as a commandline param & message text on STDIN\n";
	#print "\t2. An email from signalhq.com on STDIN\n";
	#print "\nWith option (1) the message text is the literal page text and will be scanned for\n";
	#print "name mentions to determine the recipients.\n";
	#print "With option (2) the input is a full email message.  The headers will be discarded.  The Subject\n";
	#print "is expected to include the sender's Caller ID in a particular format, and the body will\n";
	#print "be scanned for name mentions to determine the recipients.\n";
	#exit;
	$g_bBootOnly = 1;
}
else {
	@g_aSTDIN = <STDIN>;
}

if (defined $ARGV[0]) {
	if ($ARGV[0] !~ /nagios|emergency|hup|oncall/) {
		print "The only supported commandline parameter is for nagios to send pages.\n";
		print "When nagios is sending we take STDIN as literal pager text.\n";
		print "Otherwise we assume STDIN is an email to be parsed.\n";
		exit;
	}
	$sClientCallerId = $ARGV[0];
}
else {
	$sClientCallerId = parse_email_from_stdin();
}

$g_bBootOnly = 1 if (defined $ARGV[0] && $ARGV[0] eq 'hup');

if ($sClientCallerId eq 'oncall') {
	if (defined $ARGV[1]) {
		print get_oncall_name($ARGV[1], defined $ARGV[2] ? $ARGV[2] : 0) . "\n";
		exit;
	}
	print "'oncall' requires a group name\n";
	exit;
}

# is the daemon alive?
my $bDaemonLives = is_daemon_alive();

# if not, spin it up
unless ($bDaemonLives) {
	daemon_startup();  # this returns in the parent/client after forking off the child/daemon
	sleep(1);
}

unless ($g_bBootOnly) {
	# here we're in the client and have something to send to the daemon
	my $tSocket = IO::Socket::UNIX->new(
		Type => SOCK_STREAM,
		Peer => $g_sSocketPath,
	) or die("Can't connect to server: $!\n");

	print $tSocket "FF:" . $sClientCallerId . ":FF\n";
	foreach (@g_aSTDIN) {
		print $tSocket $_;
		#syslog(LOG_DEBUG, "  socket_send(): $_");
	}
	close($tSocket);
}

