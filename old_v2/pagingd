#!/usr/bin/perl -w

use strict;
use POSIX ();
use Sys::Syslog qw(:standard :macros);
use Proc::Daemon;
use IO::Socket::UNIX qw(SOCK_STREAM);
use IO::Select;
use LWP 5.64;
use URI::Escape;
use Date::Parse;
use Date::Format;
use Hash::Case::Preserve;
use Net::SMTP;
use FreezeThaw qw(freeze thaw);
use String::Random qw(random_string);
use lib "/usr/local/bin";
use paging_contacts;

use constant VERSION => '2.3.1';
use constant ONEWEEK => 604800;

# to change the name of the config file you have to do it here (below)
# as well as the "use lib" and "use paging_contacts"
use constant CONFIG_FILE_NAME => '/usr/local/bin/paging/paging_contacts.pm';

# drop root privs to become 'nobody'
$< = $> = 65534 unless ($< == 65534);

# The paging system has both a server (daemon) and client component, both included
# in this file.  External scripts wishing to send a page always call the client.  The
# client checks for the existence of the daemon and, if found, sends it the page.  If
# the daemon isn't running the client forks off a process that becomes the deamon and
# then forwards it the page.  In all cases the daemon stays running the client exits
# after forwarding on the page.
#
# The client can be called with 'nagios' as a parameter and the literal page text on
# stdin.  Or no commandline parameter and an email on stdin.  The email should be
# of the form we get from signalhq.com or answerfirst.com.

# setup globals
my $g_sAppName = 'pagingd';
my $g_sSocketPath = '/tmp/.' . $g_sAppName . '_sock';
my $g_sPIDFile = "/tmp/$g_sAppName.pid";
my %g_hTimerForRoom;	# $g_hTimerForRoom{0} = 300;
my %g_hTicketForRoom;
my $g_bBootOnly = 0;
my $g_tDaemon;
my $g_iDaemonPid;
my @g_aSTDIN;
my %g_hPeoplesRooms;	# $g_hPeoplesRooms{'Rick'} = 0;
my %g_hRoomExpirations;	# $g_hRoomExpirations[0] = time();
my %g_hBroadcastRoomOwner;  # $g_BroadcastingRoomOwner{1} = 'Rick';
my %g_hRoomHistory;
my %g_hPendingNotifies;
my %g_hSilentRecovery;
my %g_hAutoReply;
my %g_hVacationDays;
my %g_hThrottleInfo;    # $g_hThrottleInfo{5555551212} = '4/1231231212';  4 pages in the last 1 minute, since that time
my $g_tListenerSocket;
my $g_iInitBroadcastOwner = 0;
my $g_iMetricDay = '';
my $g_iMetricCount = 0;
my $g_iNagiosSnoozeTime = 0;
my $g_iRecoverySnoozeTime = 0;
my $g_sRegexBlock = '';
my $g_iRegexBlockExpire = 0;
my $g_iMaintenanceRoomNumber = -1;

use constant TEST_RUN					=> 0;     # disables pages, ticket creation & mass emails
use constant DEBUG_LEVEL				=> 1;

# install signal handlers
my $tSignalSet = POSIX::SigSet->new();
my $tSignalActionTerm = POSIX::SigAction->new("handler_daemon_exit", $tSignalSet, &POSIX::SA_NODEFER);
#my $tSignalActionHup = POSIX::SigAction->new("handler_clear_rooms", $tSignalSet, &POSIX::SA_NODEFER);
my $tSignalActionHup = POSIX::SigAction->new("handler_sighup", $tSignalSet, &POSIX::SA_NODEFER);
POSIX::sigaction(&POSIX::SIGINT, $tSignalActionTerm);
POSIX::sigaction(&POSIX::SIGTERM, $tSignalActionTerm);
POSIX::sigaction(&POSIX::SIGHUP, $tSignalActionHup);

# open syslog
openlog($g_sAppName, 'ndelay,pid', LOG_LOCAL0);


sub nl($) {
	my $bPrint = shift;
	return (!$bPrint) ? "\n\n" : '';
}



# format system output
sub fso($) {
	my $sMessage = shift;

	# $sMessage = '[' . $sMessage . ']';

	return $sMessage;
}



sub parse_user_time($) {
	my $sTimeInput = shift;

	if ($sTimeInput =~ /^\s*(\d+)([smhdw]{0,1})\s*$/i) {
		my $iOrigValue = $1;
		my $iSeconds = $1;
		my $sUnit = $2;
		my $sText = '';

		if ($sUnit eq 's') { $sText = 'second'; }
		if ($sUnit eq 'm') { $iSeconds *= 60; $sText = 'minute'; }
		if ($sUnit eq 'w') { $iSeconds *= ONEWEEK; $sText = 'week'; }
		if (($sUnit eq 'h') || ($sUnit eq '')) { $iSeconds *= 3600; $sText = 'hour'; }

		if ($sUnit eq 'd') { 
			$iSeconds *= 86400;
			$sText = 'day'; 

			# days to weeks
			if (($iOrigValue > 6) && ($iOrigValue % 7 == 0)) {
				$iOrigValue /= 7;
				$sText = 'week';
				$iSeconds = ($iOrigValue * ONEWEEK);
			}
		}

		return (0) unless $sText;
		return ($iSeconds, "$iOrigValue $sText" . ($iOrigValue > 1 ? 's' : ''));
	}

	return 0;
}



sub pretty_print_number($) {
	my $sPhone = shift;

	if (length($sPhone) == 10) {
		substr($sPhone, 3, 0) = '-';
		substr($sPhone, 7, 0) = '-';
	}

	return $sPhone;
}



sub check_alias_recursion($$);
sub check_alias_recursion($$) {
	my $sAlias = shift;
	my $rhSeenAliases = shift;
	my %hSeenAliases = %{$rhSeenAliases};

	$hSeenAliases{$sAlias} = 1;

	tie my(%hCaselessStaff), 'Hash::Case::Preserve';
	%hCaselessStaff = %hStaff;
			
	while ($hCaselessStaff{$sAlias}{alias} =~ m,(\w+),g) {

		my $sThisAliasValue = $1;
		if (defined $hCaselessStaff{$sThisAliasValue}{alias}) {
			return "$sThisAliasValue recursively used in $sAlias" if (defined $hSeenAliases{$sThisAliasValue});

			my $sResult = check_alias_recursion($sThisAliasValue, \%hSeenAliases);
			return $sResult if $sResult;
		}
	}

	return '';
}



sub boot_syntax_check() {
	my $sAt = $CFGbRequireAtForNames ? '\@' : '\b';
	my $bError = 0;

	foreach my $sGroup (keys %hStaff) {

		# schedule check
		if (defined $hStaff{$sGroup}{schedule}) {

			foreach my $sDate (sort keys %{$hStaff{$sGroup}{schedule}}) {

				if (length($sDate) != 8) {
					print STDERR nl($bError) . " - $sGroup schedule has a date of $sDate: should be 8 digits long (YYYYMMDD)\n";
					$bError = 1;
				}

				if ($hStaff{$sGroup}{schedule}{$sDate} =~ /^auto/) {
					while ($hStaff{$sGroup}{schedule}{$sDate} =~ m,(\w+),g) {
						next if ($1 =~ /^auto$/i);
						my $sSchedPerson = $1;

						my $bFound = 0;
						foreach my $sMember (keys(%{$hStaff{$sGroup}{members}})) {
							if ($sSchedPerson =~ /$sAt($sMember)\b/i) {
								$bFound = 1;
								last;
							}
						}

						unless ($bFound) {
							print STDERR nl($bError) . " - $sGroup auto schedule for $sDate lists $sSchedPerson, which matches no $sGroup member\n" . 
													"      'members' regexs are applied with word boundaries on each end: " . '\b(REGEX)\b' . "\n";
							$bError =1;
						}
                    }
				}
				else {
					my $bFound = 0;
					foreach my $sMember (keys(%{$hStaff{$sGroup}{members}})) {
						if ($hStaff{$sGroup}{schedule}{$sDate} =~ /$sAt($sMember)\b/i) {
							$bFound = 1;
							last;
						}
					}

					unless ($bFound) {
						print STDERR nl($bError) . " - $sGroup schedule for $sDate lists " . $hStaff{$sGroup}{schedule}{$sDate} . ", which matches no $sGroup member\n" .
													"      'members' regexs are applied with word boundaries on each end: " . '\b(REGEX)\b' . "\n";
						$bError =1;
					}
				}
			}
		}

		# member phone check
		if (defined $hStaff{$sGroup}{members}) {
			foreach my $sMember (keys %{$hStaff{$sGroup}{members}}) {

				unless (length($hStaff{$sGroup}{members}{$sMember}) == 10) {
					print STDERR nl($bError) . " - '$sMember' of $sGroup doesn't have a 10 digit phone number\n";
					$bError = 1;
				}
			}
		}

		# escalation check
		if (defined $hStaff{$sGroup}{escalation}) {

			if ((defined $hStaff{$sGroup}{escalation}{timer}) && !(defined $hStaff{$sGroup}{escalation}{on_expire_to})) {
				print STDERR nl($bError) . " - $sGroup has an escalation timer specified but no on_expire_to to escalate to\n";
				$bError = 1;
			}

			if ((!defined $hStaff{$sGroup}{escalation}{timer}) && (defined $hStaff{$sGroup}{escalation}{on_expire_to})) {
				print STDERR nl($bError) . " - $sGroup has an escalation on_expire_to specified but no timer to count down\n";
				$bError = 1;
			}
		}

		# alias check
		if (defined $hStaff{$sGroup}{alias}) {
			my %hNada = ();
			my $sResult =  check_alias_recursion($sGroup, \%hNada);
			if ($sResult) {
				print STDERR nl($bError) . " - Alias: $sResult (danger!)\n";
				$bError = 1;
			}
		}
	}

	# emergency group check
	if (defined($CFGsEmergencyGroup) && !defined($hStaff{$CFGsEmergencyGroup})) {
		print STDERR nl($bError) . ' - $CFGsEmergencyGroup is defined as ' . "$CFGsEmergencyGroup, which doesn't exist\n"; 
		$bError = 1;
	}

	if (defined($CFGsEmergencyGroup) && defined($hStaff{$CFGsEmergencyGroup}) && !defined($hStaff{$CFGsEmergencyGroup}{schedule})) {
		print STDERR nl($bError) . ' - $CFGsEmergencyGroup (' . "$CFGsEmergencyGroup) is lacking a schedule so we won't know who to page\n";
		$bError = 1;
	} 

	if ($bError) {
		print STDERR "\nErrors found - continuing in case this startup is automated (other functionality may still work).\n";
		print STDERR "But these errors should be corrected.  Unpredictable results may follow.\n";
	}
}


sub is_daemon_alive(;$) {
    my $iPID = shift || 0;
    my $bDaemonLives = 0;

    if (!$iPID && -f $g_sPIDFile) {
        if (open(PIDFile, $g_sPIDFile)) {
            $iPID = <PIDFile>;
            close(PIDFile);
        }
	}

    if ($iPID) {
        # normally we'd just do something like: $bDaemonLives = 1 if (kill(0, $iPID));
        # but kill(0) has the restriction that we have to be the same UID as the already
        # running daemon.  and while that would be great, it's not necessarily the case.
        # anyone should be able to invoke us on the command line (as a client).  so we
        # need a different kind of test.
        if (open(STATUS, "/proc/$iPID/status")) {
            my $sStatus = <STATUS>;
            close(STATUS);

            $bDaemonLives = 1 if ((-S $g_sSocketPath) && ($sStatus =~ /Name:\s+(new_)*pagingd/));
        }
    }

	syslog(LOG_DEBUG, "daemon lives = $bDaemonLives, pid from file = $iPID");
    return $bDaemonLives;
}



sub get_members_group($) {
	my $sPerson = shift;

	foreach my $sGroup (keys %hStaff) {
		if (defined $hStaff{$sGroup}{members}) {
			foreach my $sMember (keys %{$hStaff{$sGroup}{members}}) {
				return $sGroup if ($sPerson =~ /$sMember/i);
			}
		}
	}

	return '';
}


sub get_members_full_name($) {
	my $sPerson = shift;
	
	foreach my $sGroup (keys %hStaff) {
		if (defined $hStaff{$sGroup}{members}) {
			foreach my $sMember (keys %{$hStaff{$sGroup}{members}}) {
				return $sMember if ($sPerson =~ /$sMember/i);
			}
		}
	}

	return $sPerson;
}


sub get_oncall_name($;$) {  # oncall group, followed by optional days to add to the date
    my $sGroup = shift;
    my $iPlusDays = shift || 0;

	return '' unless (defined $hStaff{$sGroup}{schedule});

    my %hSchedule = %{$hStaff{$sGroup}{schedule}};
    my ($iMinute, $iHour, $iDay, $iMonth, $iYear) = (localtime)[1..5];
    my $iToday = sprintf("%d%02d%02d", $iYear+1900, $iMonth+1, $iDay);

    my $sPerson;
    foreach (sort keys %hSchedule) {
        my $iTodayPlus = $iPlusDays ? time2str("%Y%m%d", (str2time(substr($iToday, 0, 8)) + (86400 * $iPlusDays))) : $iToday;

        if ($iTodayPlus >= $_) {

            if ($hSchedule{$_} =~ /^auto/i) {
				my $sThisSched = $hSchedule{$_};
				my @aOnCallNames = ();
				 
				while ($sThisSched =~ m,(\w+),g) {
					next if ($1 =~ /^auto$/i);
					my $sSchedPerson = $1;

					foreach my $sMember (keys(%{$hStaff{$sGroup}{members}})) {
						if ($sSchedPerson =~ /$sMember/i) { 
							push(@aOnCallNames, $sMember);
							last;
						}
					}
				}
				if ($#aOnCallNames < 0) { @aOnCallNames = keys(%{$hStaff{$sGroup}{members}}); }

                my $iDiff = sprintf("%.0f", (((86400 * $iPlusDays) + str2time(substr($iToday, 0, 8)) - str2time(substr($_, 0, 8))) / 86400));
                $sPerson = $aOnCallNames[int($iDiff/7) % ($#aOnCallNames + 1)];
                last;
            }
            else {
				# we want to say "$sPerson = $hSchedule{$_}" but the below 'for' is to
				# handle cases where a group member is defined in one case but referenced
				# in the schedule in another, i.e. rick vs Rick
                my $sEntry = $hSchedule{$_};
     			foreach my $sMember (keys(%{$hStaff{$sGroup}{members}})) {
                	if ($sEntry =~ /$sMember/i) {
						$sPerson = $sMember;
						last;
					}
				}
            }
        }
        else {
            last;
        }
    }

    $sPerson =~ s/([^|]+).*/$1/;
    return $sPerson;
}


sub get_oncall_schedule($) {
    my $sGroup = shift;

	return 'None.' unless (defined $hStaff{$sGroup}{schedule});

	my $iWeeksShown = 0;
    my %hSchedule = %{$hStaff{$sGroup}{schedule}};
    my ($iMinute, $iHour, $iDay, $iMonth, $iYear) = (localtime)[1..5];
	my $iToday = sprintf("%d%02d%02d", $iYear+1900, $iMonth+1, $iDay);
	my $iTodaySeconds = str2time($iToday);
	my $sResult = '';

    foreach (sort keys %hSchedule) {

        if (($hSchedule{$_} =~ /^auto/i) || ($iTodaySeconds) <= str2time($_) + 604000) {

            if ($hSchedule{$_} =~ /^auto/i) {
                my $sThisSched = $hSchedule{$_};
                my @aOnCallNames = ();

                while ($sThisSched =~ m,(\w+),g) {
                    next if ($1 =~ /^auto$/i);
                    my $sSchedPerson = $1;

                    foreach my $sMember (keys(%{$hStaff{$sGroup}{members}})) {
                        if ($sSchedPerson =~ /$sMember/i) {
                            push(@aOnCallNames, $sMember);
                            last;
                        }
                    }
                }
                if ($#aOnCallNames < 0) { @aOnCallNames = keys(%{$hStaff{$sGroup}{members}}); }

				my $iPlusWeek = -1;
				while (1) {
					$iPlusWeek++;
                	my $iDiff = sprintf("%.0f", 7 * $iPlusWeek);
    				my $sPerson = $aOnCallNames[int($iDiff/7) % ($#aOnCallNames + 1)];
    				$sPerson =~ s/([^|]+).*/$1/;
					my $iNewDay = str2time($_) + ($iPlusWeek * ONEWEEK);

					next unless ($iNewDay + 604000 >= $iTodaySeconds);

                	$sResult .= time2str("%x", $iNewDay) . ": " . $sPerson . "\n";
					$iWeeksShown++;

					last if ($iWeeksShown > 4);
				}
                last;
            }
            else {
                # we want to say "$sPerson = $hSchedule{$_}" but the below 'for' is to
                # handle cases where a group member is defined in one case but referenced
                # in the schedule in another, i.e. rick vs Rick
                my $sEntry = $hSchedule{$_};
                foreach my $sMember (keys(%{$hStaff{$sGroup}{members}})) {
                    if ($sEntry =~ /$sMember/i) {
    					my $sPerson = $sMember;
    					$sPerson =~ s/([^|]+).*/$1/;
                        $sResult .= time2str("%x", str2time($_)) . ": $sPerson\n";
						$iWeeksShown++;
                        last;
                    }
                }
            }
        }
    }

	return $sResult;
}



sub write_config_with_schedule($$) {
	my $sGroup = shift;
	my $sNewSchedule = shift;

	unless (open(CFG_EXISTING, CONFIG_FILE_NAME)) {
		syslog(LOG_INFO, "write_config_with_schedule($sGroup, ...) Error: Unable to open existing config file;  file perms?");
		return 0;
	}

	unless (open(CFG_NEW, '>' . CONFIG_FILE_NAME . '.new')) { 
		syslog(LOG_INFO, "write_config_with_schedule($sGroup, ...) Error: Unable to create new config file;  file perms?");
		return 0;
	}

	my $bInGroup = 0;
	my $bInSchedule = 0;

	while (<CFG_EXISTING>) {
		my $sWorkingLine = $_;

		# lose comments so we don't get confused by something that isn't actually code
		$sWorkingLine =~ s/(?<!\$)#.*$//;
	
		# we make some assumptions here so that I don't have to write a full perl parser.
		# namely that the config is laid out with one assignment or brace per line
		# 'TeamA' => { 'schedule' => { '20130101' => 'auto' } },
		# is valid perl but this wimpy parser isn't going to handle that.  we need it
		# broken out per line like in the sample paging_contacts.pm file.

		if ($bInGroup && $bInSchedule) {
			if ($sWorkingLine =~ /\'\d{8}\'\s*=>\s*\'.*\'/) {
				next;  # don't write this *old* schedule line
			}
			elsif ($sWorkingLine =~ /\}/) {
				$bInSchedule = 0;
				$bInGroup = 0;  # not really but let's be super safe
				print CFG_NEW $sNewSchedule;
				# no next, so that below we'll add the closing brace w/original indentation
			}
		}

		$bInGroup = 1 if ($sWorkingLine =~ /\'$sGroup\'\s*=>\s*\{/);
		$bInSchedule = 1 if ($bInGroup && ($sWorkingLine =~ /\'schedule\'\s*=>\s*\{/i));
 
		print CFG_NEW $_;

		#print "*** IN GROUP ***\n" if $bInGroup;
		#print "*** IN SCHED ***\n" if $bInSchedule;
	}

	close(CFG_EXISTING);
	close(CFG_NEW);

	rename(CONFIG_FILE_NAME, CONFIG_FILE_NAME . '.prev') ||
		syslog(LOG_INFO, "write_config_with_schedule($sGroup, ...) Error: Unable to backup existing config file;  file perms?");

	return 1 if (rename(CONFIG_FILE_NAME . '.new', CONFIG_FILE_NAME));

	syslog(LOG_INFO, "write_config_with_schedule($sGroup, ...) Error: Unable to rename new config file;  file perms?");
	return 0;
}


sub swap_oncall_schedule($$) {
	my $sPersonA = shift;
	my $sPersonB = shift;
	my $sGroupA = get_members_group($sPersonA);
	my $sGroupB = get_members_group($sPersonB);
    my ($iMinute, $iHour, $iDay, $iMonth, $iYear) = (localtime)[1..5];
	my $iToday = sprintf("%d%02d%02d", $iYear+1900, $iMonth+1, $iDay);
	my $iTodaySeconds = str2time($iToday);
    my %hSchedule = %{$hStaff{$sGroupA}{schedule}};
	my %hFullSchedule;
	my @aAuto;

	if (!$sGroupB) {
		send_sms_page(get_number_from_name($sPersonA), "[That isn't a valid person in the paging system.]", $sPersonA);
		return;
	}

	if ($sGroupA ne $sGroupB) {
		send_sms_page(get_number_from_name($sPersonA), "[You can't swap schedules with someone from a different oncall group.]", $sPersonA);
		return;
	}

	# build a searchable schedule hash

    foreach (sort keys %hSchedule) {

       if (($hSchedule{$_} =~ /^auto/i) || ($iTodaySeconds <= str2time($_) + 604000)) {
			my $iDateSeconds = str2time($_);
			my $iNumberPeopleInAuto = 0;

            if ($hSchedule{$_} =~ /^auto/i) {
				my $bAutoArrayDone = 0;

				do {
					my $bAutoPeopleSpecified = 0;
                	my $sThisSched = $hSchedule{$_};

                	while ($sThisSched =~ m,(\w+),g) {
                    	next if ($1 =~ /^auto$/i);
                    	my $sSchedPerson = $1;
						$bAutoPeopleSpecified = 1;

                    	foreach my $sMember (keys(%{$hStaff{$sGroupA}{members}})) {
                        	if ($sSchedPerson =~ /$sMember/i) {
								$hFullSchedule{$iDateSeconds} = $sMember;
								$iDateSeconds += ONEWEEK;  # advance a week
								push(@aAuto, $sMember) unless $bAutoArrayDone;
                            	last;
                        	}
                    	}
                	}

					# auto with no details specified, i.e. just use group members in order
                	unless ($bAutoPeopleSpecified) { 
						foreach my $sMember (keys(%{$hStaff{$sGroupA}{members}})) {
							$hFullSchedule{$iDateSeconds} = $sMember;
							$iDateSeconds += ONEWEEK;
							push(@aAuto, $sMember) unless $bAutoArrayDone;
						}
					}
					$bAutoArrayDone = 1;
				} while ($iTodaySeconds > $iDateSeconds - (ONEWEEK * scalar(@aAuto)));
			}
			else {
                my $sEntry = $hSchedule{$_};
                foreach my $sMember (keys(%{$hStaff{$sGroupA}{members}})) {
                    if ($sEntry =~ /$sMember/i) {
						$hFullSchedule{$iDateSeconds} = $sMember;
						$iDateSeconds += ONEWEEK;
                        last;
                    }
                }
			}
		}
	}

	# prune old entries in the past

	foreach my $sDate (sort keys %hFullSchedule) {
		delete $hFullSchedule{$sDate} if ($sDate <= $iTodaySeconds - ONEWEEK);
	}

	# find the two entries to swap in the schedule

	my $iFirstDatePersonA = 0;
	my $iFirstDatePersonB = 0;
	foreach my $iDay (sort keys %hFullSchedule) {

		if (!$iFirstDatePersonA && ($sPersonA =~ /$hFullSchedule{$iDay}/i)) {
			$iFirstDatePersonA = $iDay;
		}

		if (!$iFirstDatePersonB && ($sPersonB =~ /$hFullSchedule{$iDay}/i)) {
			$iFirstDatePersonB = $iDay;
		}

		last if ($iFirstDatePersonA && $iFirstDatePersonB);
	}

	if (!$iFirstDatePersonA) {
		send_sms_page(get_number_from_name($sPersonA), "[You're not in the oncall schedule so you have nothing to swap.]", $sPersonA);
		return '';
	}

	if (!$iFirstDatePersonB) {
		send_sms_page(get_number_from_name($sPersonB), "[$sPersonB is not in the oncall schedule so they have nothing to swap.]", $sPersonB);
		return '';
	}

	# perform the swap

	$hFullSchedule{$iFirstDatePersonA} = get_members_full_name($sPersonB);
	$hFullSchedule{$iFirstDatePersonB} = get_members_full_name($sPersonA);

	# recreate the new schedule - find where to convert to "auto"

	my $bFail;
	my $iAutoDate = 0;
	foreach my $iDay (sort keys %hFullSchedule) {
		$bFail = 0;

		foreach my $iIndex (1 .. scalar(@aAuto)) {
			#print "   - looking at $iIndex on $iDay " . time2str("%x", $iDay + (($iIndex - 1) * ONEWEEK)) . "\n";
			last unless defined($hFullSchedule{$iDay + (($iIndex - 1) * ONEWEEK)});
			#print "     - looking at " . $hFullSchedule{$iDay + (($iIndex - 1) * ONEWEEK)} . "\n";
			next if ($aAuto[$iIndex - 1] =~ /$hFullSchedule{$iDay + (($iIndex - 1) * ONEWEEK)}/i);
			#print "     - failed\n";
			$bFail = 1;
			last;
		}

		if (!$bFail) {
			$iAutoDate = $iDay;
			last;
		}
	}

	if (!$iAutoDate) {
		my @aTemp = sort keys %hFullSchedule;
		$iAutoDate = $aTemp[$#aTemp] + ONEWEEK;
		$hFullSchedule{$iAutoDate} = $aAuto[0];
	}

	my $bConfigScheduleDone = 0;
	my $sConfigSchedule = '';
	my $sTextSchedule = '';
	foreach my $iDay (sort keys %hFullSchedule) {
		if ($iDay == $iAutoDate) {
			my $sAutoList = '';
			for my $sAutoEntry (@aAuto) {
    			$sAutoEntry =~ s/([^|]+).*/$1/;
				$sAutoList .= (length($sAutoList) ? ',' : '') . $sAutoEntry;
			}
			$sConfigSchedule .= "\t\t\t\t\'" . time2str("%Y%m%d", $iDay) . "\' => \'auto/$sAutoList\',\n" unless $bConfigScheduleDone;

    		my $sPerson = $hFullSchedule{$iDay};
    		$sPerson =~ s/([^|]+).*/$1/;
			$sTextSchedule .= time2str("%x", $iDay) . ": $sPerson\n";
			$bConfigScheduleDone = 1;
		}	
		else {
    		my $sPerson = $hFullSchedule{$iDay};
    		$sPerson =~ s/([^|]+).*/$1/;
			$sConfigSchedule .= "\t\t\t\t\'" . time2str("%Y%m%d", $iDay) . "\' => \'$sPerson\',\n" unless $bConfigScheduleDone;
			$sTextSchedule .= time2str("%x", $iDay) . ": $sPerson\n";
		}
	}

	if (write_config_with_schedule($sGroupA, $sConfigSchedule)) {
		send_sms_page(get_number_from_name($sPersonA), "[You've successfully swapped weeks with $sPersonB]", $sPersonA);
		send_sms_page(get_number_from_name($sPersonA), $sTextSchedule, $sPersonA);

		my $sFormalName = get_name_from_number(get_number_from_name($sPersonB));
		send_swap_email($hStaff{$sGroupA}{email}, "$sPersonA has swapped weeks with $sFormalName.\n\nThe new schedule for $sGroupA is as follows:\n\n" . $sTextSchedule)
			if defined($hStaff{$sGroupA}{email});

		# send ourselves a sighup - will reinstantiate our daemon and reread the config
		syslog(LOG_INFO, "Sending ourselves a SIGHUP to reread the config");
		kill('HUP', $$);
	}
	else {
		send_sms_page(get_number_from_name($sPersonA), "[Unable to update the schedule.  Please notify your administrator.]", $sPersonA);
	}

	return '';
}



sub get_name_from_number($) {
    my $sNumber = shift;

    return "PI" if ($sNumber eq "9999999999");

    if (length($sNumber) > 9) {
        foreach my $sGroup (keys %hStaff) {

            if (defined $hStaff{$sGroup}{members}) {
                foreach my $sMember (keys %{$hStaff{$sGroup}{members}}) {
                    if ($hStaff{$sGroup}{members}{$sMember} =~ /^$sNumber/) {
                        $sMember =~ s/([^|]+).*/$1/;
                        return $sMember;
                    }
                }
            }
        }
    }

    return $sNumber;
}



sub get_number_from_name($) {
    my $sName = shift;

    foreach my $sGroup (keys %hStaff) {
        if (defined $hStaff{$sGroup}{members}) {
            foreach my $sMember (keys %{$hStaff{$sGroup}{members}}) {
				syslog(LOG_INFO, "get_number_from_name($sName) considering $sMember") if (DEBUG_LEVEL > 4);
                return $hStaff{$sGroup}{members}{$sMember} if ($sName =~ /\b($sMember)\b/i);
            }
        }

    }

    return "";
}



sub daily_housekeeping() {
    my ($iMinute, $iHour, $iDay, $iMonth, $iYear) = (localtime)[1..5];
    my $iToday = sprintf("%d%02d%02d", $iYear+1900, $iMonth+1, $iDay);
	
	unless ($g_iMetricDay eq $iToday) {

		# write the daily total to the metrics log
		if ($g_iMetricDay && open(METRIC_LOG, ">>/tmp/pagingd_metrics.log")) {
			print METRIC_LOG "Total pages sent for $g_iMetricDay were $g_iMetricCount\n"; 
			close(METRIC_LOG);
		}

		$g_iMetricDay = $iToday;
		$g_iMetricCount = 0;

		# decrement any defined vacation days by one - remove completely if zero
		foreach my $sPerson (keys %g_hVacationDays) {
			--$g_hVacationDays{$sPerson};

			if (!$g_hVacationDays{$sPerson}) {
				delete $g_hVacationDays{$sPerson}; 
				send_vacation_email($sPerson, -1);
			}
		}
	}
}


sub handler_sighup() {
    $g_tListenerSocket->shutdown(2);
	$g_tListenerSocket->close();
    unlink($g_sSocketPath)  or syslog(LOG_INFO, "cannot unlink: $!");;
    unlink($g_sPIDFile) or syslog(LOG_INFO, "cannot unlink: $!");
    syslog(LOG_INFO, "Total pages sent for $g_iMetricDay were $g_iMetricCount") if $g_iMetricDay;
    syslog(LOG_DEBUG, "daemon caught SIGHUP (execing $0)");
    closelog();    # syslog
	save_state(1);
	exec("$0 hup");
	exit;
}



sub handler_daemon_exit() {
	$g_tListenerSocket->shutdown(2);
	$g_tListenerSocket->close();
	unlink($g_sPIDFile);
	unlink($g_sSocketPath);
	syslog(LOG_INFO, "Total pages sent for $g_iMetricDay were $g_iMetricCount") if $g_iMetricDay;
	syslog(LOG_DEBUG, 'daemon exiting on signal');
	closelog();    # syslog
	save_state(0);
	exit;
}



sub handler_clear_rooms() {
	foreach (keys %g_hPeoplesRooms) {
		delete($g_hPeoplesRooms{$_});
	}

	foreach (keys %g_hRoomExpirations) {
		delete($g_hRoomExpirations{$_});
	}

	foreach (keys %g_hBroadcastRoomOwner) {
		delete($g_hBroadcastRoomOwner{$_});
	}

	foreach (keys %g_hRoomHistory) {
		delete($g_hRoomHistory{$_});
	}

	foreach (keys %g_hPendingNotifies) {
		delete($g_hPendingNotifies{$_});
	}

	foreach (keys %g_hTimerForRoom) {
		delete($g_hTimerForRoom{$_});
	}

	foreach (keys %g_hTicketForRoom) {
		delete($g_hTicketForRoom{$_});
	}

	$g_iInitBroadcastOwner = 0;
	syslog(LOG_INFO, "Caught SIGHUP: all rooms, timers/escalations, history cleared.");
}



sub delete_room($) {
	my $iRoom = shift;

	delete $g_hRoomExpirations{$iRoom};
	delete $g_hRoomHistory{$iRoom};
	delete $g_hTicketForRoom{$iRoom} if (defined $g_hTicketForRoom{$iRoom});
	delete $g_hTimerForRoom{$iRoom} if (defined $g_hTimerForRoom{$iRoom});
	delete $g_hBroadcastRoomOwner{$iRoom} if (defined $g_hBroadcastRoomOwner{$iRoom});
	$g_iMaintenanceRoomNumber = -1 if ($iRoom == $g_iMaintenanceRoomNumber);
}



sub send_emergency_email($$) {
	my $iTicketNumber = shift;
	my $sMessage = shift;

	my $tSMTP = Net::SMTP->new($CFGsEmergencySMTPServer);
	$tSMTP->mail($CFGsEmergencySMTPFrom);

	if (TEST_RUN) {
		$tSMTP->to($CFGsAdminEmail);
	}
	else {
		my @aRecips = split(/\s*,\s*/, $CFGsEmergencySMTPTo);
		foreach (@aRecips) {
			$tSMTP->to($_);
		}
	}

	$tSMTP->data();
	$tSMTP->datasend("From: <$CFGsEmergencySMTPFrom>\n");
	$tSMTP->datasend("To: $CFGsEmergencySMTPTo\n");
	$tSMTP->datasend("Subject: EMERGENCY CALL\n");
	$tSMTP->datasend("\n");
	$tSMTP->datasend($sMessage);
	$tSMTP->datasend("\n\n----\nThis event is being tracked in RT ticket #$iTicketNumber\n");
	$tSMTP->datasend("$CFGsEmergencyRTLink$iTicketNumber\n");
	$tSMTP->dataend();
	$tSMTP->quit();
}



sub send_vacation_email($$) {
	my $sPerson = shift;
	my $iDays = shift;

	my $tSMTP = Net::SMTP->new($CFGsEmergencySMTPServer);
	$tSMTP->mail($CFGsEmergencySMTPFrom);

	if (TEST_RUN) {
		$tSMTP->to($CFGsAdminEmail);
	}
	else {
		my @aRecips = split(/\s*,\s*/, $CFGsVacationSMTPTo);
		foreach (@aRecips) {
			$tSMTP->to($_);
		}
	}

	$tSMTP->data();
	$tSMTP->datasend("From: <$CFGsEmergencySMTPFrom>\n");
	$tSMTP->datasend("To: $CFGsVacationSMTPTo\n");
	$tSMTP->datasend("Subject: Paging system vacation update\n");
	$tSMTP->datasend("\n");

	if ($iDays > 0) {
		$tSMTP->datasend("$sPerson has just set $iDays day(s) of paging vacation time.\n");
		$tSMTP->datasend("This person will be removed from all on call and group pages.  However you can still\n");
		$tSMTP->datasend("contact them directly by name, if necessary.\n\n");
	}
	elsif ($iDays < 0) {  # vacation time expired
		$tSMTP->datasend("$sPerson\'s configured paging vacation time has elapsed.\n");
		$tSMTP->datasend("This person is now restored to all paging groups.\n\n");
	}
	else {  # vacation time manually canceled
		$tSMTP->datasend("$sPerson has just canceled their configured paging vacation time.\n");
		$tSMTP->datasend("This person is now restored to all paging groups.\n\n");
	}

	$tSMTP->datasend("The paging command '?vacation' can be used to show everyone that currently has vacation\n");
	$tSMTP->datasend("days set.\n");
	$tSMTP->dataend();
	$tSMTP->quit();
}



sub send_swap_email($$) {
	my $sAddress = shift;
	my $sMessage = shift;


	if ($sAddress =~ /\b([A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4})\b/i) {
		my $sRecipient = $1;
		my $tSMTP = Net::SMTP->new($CFGsEmergencySMTPServer);
		$tSMTP->mail($CFGsEmergencySMTPFrom);

		$tSMTP->to($sRecipient) unless TEST_RUN;
		$tSMTP->to($CFGsAdminEmail);

		$tSMTP->data();
		$tSMTP->datasend("From: <$CFGsEmergencySMTPFrom>\n");
		$tSMTP->datasend("To: $sRecipient\n");
		$tSMTP->datasend("Subject: Paging system OnCall schedule change\n");
		$tSMTP->datasend("\n");
		$tSMTP->datasend($sMessage);
		$tSMTP->dataend();
		$tSMTP->quit();
	}
}



sub send_history_email($$) {
	my $sSpeaker = shift;
	my $sAddress = shift;
	my $iRoom = $g_hPeoplesRooms{$sSpeaker};
	
	if ($sAddress =~ /\b([A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4})\b/i) {
		my $sRecipient = $1;
		my $tSMTP = Net::SMTP->new($CFGsEmergencySMTPServer);
		$tSMTP->mail($CFGsEmergencySMTPFrom);
		$tSMTP->to($sRecipient);

		$tSMTP->data();
		$tSMTP->datasend("From: <$CFGsEmergencySMTPFrom>\n");
		$tSMTP->datasend("To: $sRecipient\n");
		$tSMTP->datasend("Subject: Paging system chat history - " . room_status($iRoom) . "\n");
		$tSMTP->datasend("\n");
		$tSMTP->datasend(get_history($iRoom, 1));
		$tSMTP->dataend();
		$tSMTP->quit();
	}
}



sub rt_command($;$) {
	my $sCommand = shift;
	my $sInput = shift || '';
	my $sResult;

	if ($sInput) {
		$sResult = `/bin/echo "$sInput" | $CFGsRTConnectionString $sCommand`;
	}
	else {
		$sResult = `$CFGsRTConnectionString $sCommand`;
	}

	syslog(LOG_DEBUG, "rt_command ($sCommand): $sResult");
	return $sResult;
}



sub sleeping_hours() {
	my ($iMinute, $iHour) = (localtime(time()))[1..2];
	return ($iHour < 8 || $iHour > 21);
}


# this generates an English representation of a rounded calculation
sub print_time($) {
	my $iSeconds = shift;
	my $iValue = $iSeconds + ($iSeconds * 0.07);  # buffer up a bit
	my $iCurrentUnit = 1;
	my @aMultipliers = (1, 60, 60, 24, 7, 4, 12);
	my @aUnits = ('second', 'minute', 'hour', 'day', 'week', 'month', 'year');
	
	while ($iValue >= $aMultipliers[$iCurrentUnit]) {
		$iValue = int($iValue / $aMultipliers[$iCurrentUnit]);
		++$iCurrentUnit;
	}

	return("$iValue " . $aUnits[$iCurrentUnit - 1] . ($iValue > 1 ? 's' : ''));
}


sub get_history($;$) {
	my $iRoom = shift;
	my $bForEmail = shift || 0;

	if (defined $g_hRoomHistory{$iRoom}) {
		my @aHistory = @{$g_hRoomHistory{$iRoom}};
		return join($bForEmail ? "\n\n" : '; ', @aHistory);
	}

	return '';
}


sub create_911_rt_ticket($) {
	my $sMessage = shift;
	my $iTicketNumber = 0;

    if (rt_command("create -t ticket set queue=$CFGsRTTicketQueue subject=\\'EMERGENCY CALL\\'") =~ /Ticket (\d+) created/) {
    	$iTicketNumber = $1;
    	rt_command("comment -m - $iTicketNumber", $sMessage);
    	syslog(LOG_DEBUG, "RT: created ticket $iTicketNumber");
    }

	return $iTicketNumber;
}



sub handle_paging_commands($$) {
	my $sSpeaker = shift;
	my $sMessage = shift;

	# if the message starts with a ! take it literally;  ignore commands
	return 0 if ($sMessage =~ /^\!/);

	# handle ambiguous name references
	my $sAmbiguousReply = '';
	foreach my $sName (keys %hAmbiguousNames) {
		if ($sMessage =~ /\b($sName)\b/i) {
			syslog(LOG_INFO, "Ambiguous name reference ($1) from $sSpeaker");
			$sAmbiguousReply .= "'$1' is ambiguous, try " . $hAmbiguousNames{$sName} . '. ';
		}
	}

	if ($sAmbiguousReply) {
		send_sms_page(get_number_from_name($sSpeaker), '[' . $sAmbiguousReply . "Your message was NOT sent.]", $sSpeaker);
		return 1;
	}

	# setup a broadcast room for single person replies
	if ($sMessage =~ /^\^/) {
		$g_iInitBroadcastOwner = $sSpeaker;
		return 0;
	}

	# swap oncall weeks with someone on your team
	if ($sMessage =~ /^\s*:swap (\w+)/) {
		swap_oncall_schedule($sSpeaker, $1);
		return 1;
	}

	# no regex
	if ($sMessage =~ /^\s*:(?:nore|noregex)\s+(\d+[shmdw]{0,1})\s+(.*)/) {
		if ($2) {
			my ($iSeconds, $sText) = parse_user_time($1);
			$g_iRegexBlockExpire = time() + $iSeconds;
			$g_sRegexBlock = $2;
			$g_sRegexBlock =~ s,/(.*)/,$1,;    # lose the delimiting slashes if the user specified them

        	my $bSleepyTime = sleeping_hours();
        	my $iSpeakersRoom = $g_hPeoplesRooms{$sSpeaker};

        	foreach (keys %g_hPeoplesRooms) {
            	if ($g_hPeoplesRooms{$_} == $iSpeakersRoom) {
                	next if ($_ eq 'nagios');
                	next if ($_ eq $sSpeaker);

                	send_sms_page(get_number_from_name($_), "[$sSpeaker has silenced /$g_sRegexBlock/ alerts for the next $sText]", $sSpeaker) unless $bSleepyTime;
            	}
        	}

        	send_sms_page(get_number_from_name($sSpeaker), "[/$g_sRegexBlock/ alerts silenced for the next $sText]", $sSpeaker);
        	return 1;
		}
	}

	# recovery snooze time
	if ($sMessage =~ /^\s*:sleep/) {
		$g_iRecoverySnoozeTime = time() + 10800;  # 3 hours
		syslog(LOG_INFO, "Setting RecoverySnoozeTime = $g_iRecoverySnoozeTime");
		send_sms_page(get_number_from_name($sSpeaker), "[Nagios load & recoveries silenced for everyone for the next 3 hours]", $sSpeaker);
		return 1;
	}

	# setup a maintenance window room
	if ($sMessage =~ /^\s*:maint(?:enance)*/) {
		combine_rooms($g_iMaintenanceRoomNumber, $sSpeaker) if ($g_iMaintenanceRoomNumber > -1);
		combine_rooms($sSpeaker, 'nagios');

		# combine_rooms() sets up pending notifications that we don't want here
		foreach my $sPerson (keys %g_hPendingNotifies) {
			delete $g_hPendingNotifies{$sPerson};
		}

		$g_iMaintenanceRoomNumber = $g_hPeoplesRooms{$sSpeaker};
	    $g_hRoomExpirations{$g_iMaintenanceRoomNumber} = time() + 5400;

        foreach (keys %g_hPeoplesRooms) {
            if ($g_hPeoplesRooms{$_} == $g_iMaintenanceRoomNumber) {
                next if ($_ eq 'nagios');

                send_sms_page(get_number_from_name($_), "[" . ($_ eq $sSpeaker ? 'You have' : "$sSpeaker has") . " designated this a maintenance window room]", $sSpeaker); 
            }
        }

		return 1;
	}

	# no nagios alerts (problem or recovery) for the specified number of hours
	if ($sMessage =~ /^\s*:\s*nonagios\s+(\d+[shmdw]{0,1})/) {
        my ($iSeconds, $sText) = parse_user_time($1);
		$g_iNagiosSnoozeTime = time() + $iSeconds;
		syslog(LOG_INFO, "Setting NagiosSnoozeTime = $g_iNagiosSnoozeTime");

        my $bSleepyTime = sleeping_hours();
        my $iSpeakersRoom = $g_hPeoplesRooms{$sSpeaker};

        foreach (keys %g_hPeoplesRooms) {
            if ($g_hPeoplesRooms{$_} == $iSpeakersRoom) {
                next if ($_ eq 'nagios');
                next if ($_ eq $sSpeaker);

                send_sms_page(get_number_from_name($_), "[$sSpeaker has silenced nagios alerts for the next $sText]", $sSpeaker) unless $bSleepyTime;
            }
        }

		send_sms_page(get_number_from_name($sSpeaker), "[Nagios alerts silenced for the next $sText]", $sSpeaker);
		return 1;
	}

	# re-enable nagios alerts
	if ($sMessage =~ /^\s*:\s*nagios/) {
		syslog(LOG_INFO, "Canceling NagiosSnoozeTime");
        my $bSleepyTime = sleeping_hours();
        my $iSpeakersRoom = $g_hPeoplesRooms{$sSpeaker};

        foreach (keys %g_hPeoplesRooms) {
            if ($g_hPeoplesRooms{$_} == $iSpeakersRoom) {
                next if ($_ eq 'nagios');
                next if ($_ eq $sSpeaker);

                send_sms_page(get_number_from_name($_), "[$sSpeaker has restored nagios alerts.]", $sSpeaker) unless $bSleepyTime;
            }
        }

		send_sms_page(get_number_from_name($sSpeaker), ($g_iNagiosSnoozeTime ? "[Nagios alerts restored.]" : "[Nagios alerts are already active.]"), $sSpeaker);
		$g_iNagiosSnoozeTime = 0;
		return 1;
	}

	# snooze - nagios silence macro for 15 minutes
	if ($sMessage =~ /^\s*:\s*snooze/) {
		$g_iNagiosSnoozeTime = time() + 900;
		syslog(LOG_INFO, "Setting NagiosSnoozeTime = $g_iNagiosSnoozeTime");

        my $bSleepyTime = sleeping_hours();
        my $iSpeakersRoom = $g_hPeoplesRooms{$sSpeaker};

        foreach (keys %g_hPeoplesRooms) {
            if ($g_hPeoplesRooms{$_} == $iSpeakersRoom) {
                next if ($_ eq 'nagios');
				next if ($_ eq $sSpeaker);

                send_sms_page(get_number_from_name($_), "[$sSpeaker has silenced nagios alerts for 15 minutes.]", $sSpeaker) unless $bSleepyTime;
            }
        }

		send_sms_page(get_number_from_name($sSpeaker), "[Nagios alerts " . ($bSleepyTime ? 'silently ' : '') . "silenced for 15 minutes.]", $sSpeaker);
		return 1;
	}

	# set an auto relpy
	if ($sMessage =~ /^\s*:\s*(?:autoreply|ar)\s+(\d+[shmdw]{0,1})\s+(.*)/) {
        my ($iSeconds, $sText) = parse_user_time($1);
 		$g_hAutoReply{$sSpeaker} = { 'expire' => (time() + $iSeconds), 'reply' => $2 };
		syslog(LOG_INFO, "$sSpeaker set an auto reply for $sText: $2");
		send_sms_page(get_number_from_name($sSpeaker), "[Your auto reply is set for the next $sText]", $sSpeaker);
		return 1;
	}

	# send someone history of your room - pulls them into the room if they're not already
	if (($sMessage =~ /^\s*\+\s*(\w+)/) || ($sMessage =~ /^\s*:\s*history\s+(\w+)/)) {
		my $sLateArriver = $1;
		my $sCellPhone = get_number_from_name($sLateArriver);

		if ($sCellPhone =~ /^\d\d/) {
			if (defined $g_hRoomHistory{$g_hPeoplesRooms{$sSpeaker}}) {
				my @aRoomHistory = @{$g_hRoomHistory{$g_hPeoplesRooms{$sSpeaker}}};
				my $iStartIdx = ($#aRoomHistory < 4) ? 0 : $#aRoomHistory - 4;
				syslog(LOG_INFO, "Sending chat history to $sLateArriver from $sSpeaker");
				
				if ($#aRoomHistory > -1) {
					send_sms_page($sCellPhone, "[CHAT HISTORY via $sSpeaker]+", $sSpeaker);
					for my $iIdx ($iStartIdx .. $#aRoomHistory) {
						send_sms_page($sCellPhone, "+" . $aRoomHistory[$iIdx], $sSpeaker);
					}
				}
				my $iMsgCount = $#aRoomHistory - $iStartIdx + 1;
				# send_sms_page(get_number_from_name($sSpeaker), "[Sent $iMsgCount message" . ($iMsgCount == 1 ? '' : 's') . ']', $sSpeaker);

				# is there an escalation we may need to disarm too?
       			foreach my $iEscalationRoomNumber (keys %g_hTimerForRoom) {
            		if ($g_hPeoplesRooms{$sSpeaker} == $iEscalationRoomNumber) {
    					delete($g_hTimerForRoom{$iEscalationRoomNumber});
						syslog(LOG_INFO, "Deleting escalation timer for room $iEscalationRoomNumber due to chat history reply");
					}
				
				}

			}
			my $sOfficialName = get_name_from_number($sCellPhone);
			process_mentions($sSpeaker, $sMessage);
			process_notifies($sSpeaker, "Chat History: $sSpeaker -> $sOfficialName");
		}
		else {
			send_sms_page(get_number_from_name($sSpeaker), "[I don't have a number for the person you want to send message history to]", $sSpeaker);
		}
		return 1;
	}

	# email someone history of your room
	if (($sMessage =~ /^\s*>\s*([A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4})\b\s*$/i) || ($sMessage =~ /^\s*:\s*email\s+([A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,4})\b\s*$/i)) {
		send_history_email($sSpeaker, $1);
		send_sms_page(get_number_from_name($sSpeaker), "[Room history emailed to $1]", $sSpeaker);
		return 1;
	}

	# all rooms status
	if ($sMessage =~ /^\s*\?\s*room/) {
		syslog(LOG_INFO, "Sending all room status to $sSpeaker");
		send_sms_page(get_number_from_name($sSpeaker), '[' . room_status(-1) . ']', $sSpeaker);
		return 1;
	
	}

	# show help
	if ($sMessage =~ /^\s*\?\s*$/) {
		#my $sHelp1 = "Silencing\n!x Skip x recoveries\n! Skip all recoveries\n-x Set vacation days\n- Leave room\n!disband Disband room\n\nRT\n~? Get ticket #\n~Txt Unlogged\n~! Stop logging";
		#my $sHelp2 = "Status Info\n= All rooms\n-? Vacation\n?? On Call\n?name Define name\n\nMisc\n+Name Send history\n>addy Email history\n:Txt Literal (ignore cmds & names)";
		my $sHelp1 = ":norecovery X\n:recovery\n:vacation X\n?vacation\n?rooms\n?oncall\n:leave\n:stoprt\n?rt\n:history NAME\n";
		my $sHelp2 = ":email ADDR\n!no log\n:nonagios X\n:nagios\n:snooze\n:autoreply\n:noregex X /re/";

		send_sms_page(get_number_from_name($sSpeaker), $sHelp1, $sSpeaker);
		send_sms_page(get_number_from_name($sSpeaker), $sHelp2, $sSpeaker);
		return 1;
	} 

	# show who's on call
	if ($sMessage =~ /^\s*\?\s*oncall/) {
		my $sOnCallMessage = '';
		foreach my $sGroup (keys %hStaff) {
			if (defined $hStaff{$sGroup}{schedule}) {
				$sOnCallMessage .= (length($sOnCallMessage) ? ";\n" : '') . "$sGroup: " . get_oncall_name($sGroup);
			}
		}
		$sOnCallMessage = '[No teams have On Call schedules defined]' unless $sOnCallMessage;
		send_sms_page(get_number_from_name($sSpeaker), "[$sOnCallMessage]", $sSpeaker);
		send_sms_page(get_number_from_name($sSpeaker), get_oncall_schedule(get_members_group($sSpeaker)), $sSpeaker);
		return 1;
	} 
 
	# show vacation days
	if ($sMessage =~ /^\s*\?\s*vacation/) {
		my $sVacations = vacation_status();
		send_sms_page(get_number_from_name($sSpeaker), $sVacations ? $sVacations : "[No one currently has vacation time configured]", $sSpeaker);

		return 1;
	}

    # RT - show ticket number
    if ($sMessage =~ /^\s*\?\s*rt/) {
        if (defined $g_hTicketForRoom{$g_hPeoplesRooms{$sSpeaker}}) {
            send_sms_page(get_number_from_name($sSpeaker), "[This room is logging to RT ticket " . $g_hTicketForRoom{$g_hPeoplesRooms{$sSpeaker}} . ".]", $sSpeaker);
        }
        else {
            send_sms_page(get_number_from_name($sSpeaker), "[This room has no association to an RT ticket.]", $sSpeaker);
        }
        return 1;
    }

	# send stats on filtered pages
	if ($sMessage =~ /^\s*\?\s*(sleep|filter)\s*$/i) {
		my $iNow = time();
		my $sStatus = 'All nagios: ' . (($g_iNagiosSnoozeTime > $iNow) ? print_time($g_iNagiosSnoozeTime - $iNow) : 'none') . "\n";
		$sStatus .=   'Load/Rcvry: ' . (($g_iRecoverySnoozeTime > $iNow) ? print_time($g_iRecoverySnoozeTime - $iNow) : 'none') . "\n";
		$sStatus .=   'Regex: ' . (($g_iRegexBlockExpire > $iNow) ? ("/$g_sRegexBlock/, " . print_time($g_iRegexBlockExpire - $iNow)) : 'none') . "\n";

        send_sms_page(get_number_from_name($sSpeaker), "[$sStatus]", $sSpeaker);

		return 1;
	}

    # send a group or member definition
    if ($sMessage =~ /^\s*\?\s*(\w+)/) {
        my $sGroup = $1;

        tie my(%hCaselessStaff), 'Hash::Case::Preserve';
        %hCaselessStaff = %hStaff;
        if ((defined $hCaselessStaff{$sGroup}) && (defined $hCaselessStaff{$sGroup}{members})) {
            # send_sms_page(get_number_from_name($sSpeaker), "[$sGroup = " . join(', ', sort keys %{$hCaselessStaff{$sGroup}{members}}) . ']', $sSpeaker);
            send_sms_page(get_number_from_name($sSpeaker), "[$sGroup = " . join(', ', sort map { s/([^|]+).*/$1/; $_; } keys %{$hCaselessStaff{$sGroup}{members}}) . ']', $sSpeaker);
        }
        elsif ((defined $hCaselessStaff{$sGroup}) && (defined $hCaselessStaff{$sGroup}{alias})) {
            send_sms_page(get_number_from_name($sSpeaker), "[$sGroup = " . $hCaselessStaff{$sGroup}{alias} . ']', $sSpeaker);
        }
        elsif (my $sNumber = get_number_from_name($sGroup)) {
			send_sms_page(get_number_from_name($sSpeaker), '[' . get_name_from_number($sNumber) . " = " . pretty_print_number($sNumber) . "]", $sSpeaker); 
		}
		else {
            send_sms_page(get_number_from_name($sSpeaker), "[There is no defined group or alias called $sGroup]", $sSpeaker);
        }

		return 1;
    }

	# RT - remove the ticket assocation from a room early (pre-room expiration)
	if ($sMessage =~ /^:\s*(stoprt|nort)/) {
		if (defined $g_hTicketForRoom{$g_hPeoplesRooms{$sSpeaker}}) {
			delete($g_hTicketForRoom{$g_hPeoplesRooms{$sSpeaker}});
			send_sms_page(get_number_from_name($sSpeaker), "[This room is no longer logged to an RT ticket.]", $sSpeaker);
		}
		else {
            send_sms_page(get_number_from_name($sSpeaker), "[This room has no association to an RT ticket.]", $sSpeaker);
		}
		return 1;
	}

	# remove myself from the room
	if (($sMessage =~ /^\s*-\s*$/) || ($sMessage =~ /^\s*:\s*leave/)) {
		my $bSleepyTime = sleeping_hours();
		my $iSpeakersRoom = $g_hPeoplesRooms{$sSpeaker};
		delete $g_hPeoplesRooms{$sSpeaker};
		syslog(LOG_INFO, "$sSpeaker voluntarily left room $iSpeakersRoom");
		
		my $iPeople = 0;
		my $sLastPersonInRoom = '';
		foreach (keys %g_hPeoplesRooms) {
			if ($g_hPeoplesRooms{$_} == $iSpeakersRoom) {
				next if ($_ eq 'nagios');

				$iPeople++;
				$sLastPersonInRoom = $_;
				send_sms_page(get_number_from_name($_), "[$sSpeaker left the room]", $sSpeaker) unless $bSleepyTime;
			} 
		}
		send_sms_page(get_number_from_name($sSpeaker), "[You " . ($bSleepyTime ? 'silently ' : '') . "left the room/conversation]", $sSpeaker);

		# zero or 1 person is left in the room, let's clean it up
		unless ($iPeople > 1) {
			syslog(LOG_INFO, "Cleaning up room $iSpeakersRoom (previously $iPeople occupant(s) remained)");
			delete $g_hPeoplesRooms{$sLastPersonInRoom} if ($iPeople == 1);
			delete_room($iSpeakersRoom);
		}

		return 1;
	}

	# update vacation days
	if ($sMessage =~ /^\s*:\s*vaca(?:tion)*\s+(\d+[shmdw]{0,1})/) {
        my ($iSeconds, $sText) = parse_user_time($1);

		if ($iSeconds && ($iSeconds < 86400)) {
			send_sms_page(get_number_from_name($sSpeaker), "[Minimum vacation is 1 day (e.g. 1d) and elapses at midnight]", $sSpeaker);
			return 1;
		}

		my $iRoundedDays = int($iSeconds / 86400);
        ($iSeconds, $sText) = parse_user_time($iRoundedDays . 'd');

		if ($iRoundedDays) {
			$g_hVacationDays{$sSpeaker} = $iRoundedDays;
		}
		else {
			delete($g_hVacationDays{$sSpeaker});
		}
		syslog(LOG_INFO, "Setting $iRoundedDays vacation days for $sSpeaker");
		send_sms_page(get_number_from_name($sSpeaker), ($iRoundedDays? "[Your vacation is now set to $sText]" : "[Your vacation settings have been removed]"), $sSpeaker);
		send_vacation_email($sSpeaker, $iRoundedDays);

		return 1;
	}


	# silence recovery pages
	if ($sMessage =~ /^\s*:\s*norecovery(?:\s+(\d+))*$/) {
		if ($1 > 0) {
			$g_hSilentRecovery{$sSpeaker} = $1;
			syslog(LOG_INFO, "Silencing $1 RECOVERY page(s) for $sSpeaker");
			send_sms_page(get_number_from_name($sSpeaker), "[The next $1 recovery page" . ($1 > 1 ? 's are' : ' is') .  " now silenced for you]", $sSpeaker);
		}
		elsif (($1 eq '0') || (defined $g_hSilentRecovery{$sSpeaker})) {
			delete($g_hSilentRecovery{$sSpeaker});
			syslog(LOG_INFO, "Restoring RECOVERY pages for $sSpeaker");
			send_sms_page(get_number_from_name($sSpeaker), "[Recovery pages are now restored for you]", $sSpeaker);
		}
		else {
			$g_hSilentRecovery{$sSpeaker} = -1;
			syslog(LOG_INFO, "Silencing RECOVERY pages for $sSpeaker");
			send_sms_page(get_number_from_name($sSpeaker), "[Recovery pages are now silenced for you]", $sSpeaker);
		}

		return 1;
	}

	if ($sMessage =~ /^\s*:\s*recovery/) {
            delete($g_hSilentRecovery{$sSpeaker}) if (defined $g_hSilentRecovery{$sSpeaker});
            syslog(LOG_INFO, "Restoring RECOVERY pages for $sSpeaker");
            send_sms_page(get_number_from_name($sSpeaker), "[Recovery pages are now restored for you]", $sSpeaker);
			return 1;
	}

	# disband room
	if ($sMessage =~ /^\s*:disband/i) {
        my $bSleepyTime = sleeping_hours();
        my $iSpeakersRoom = $g_hPeoplesRooms{$sSpeaker};
        delete $g_hPeoplesRooms{$sSpeaker};
        syslog(LOG_INFO, "$sSpeaker disbanded room $iSpeakersRoom");

        foreach (keys %g_hPeoplesRooms) {
            if ($g_hPeoplesRooms{$_} == $iSpeakersRoom) {
        		delete $g_hPeoplesRooms{$_};
                next if ($_ eq 'nagios');

                send_sms_page(get_number_from_name($_), "[$sSpeaker has disbanded the room]", $sSpeaker) unless $bSleepyTime;
            } 
        }

        send_sms_page(get_number_from_name($sSpeaker), "[You " . ($bSleepyTime ? 'silently ' : '') . "disbanded the room]", $sSpeaker);
        syslog(LOG_INFO, "Cleaning up room $iSpeakersRoom");
        delete_room($iSpeakersRoom);

        return 1;
	}

	if ($sMessage =~ /^[:?]/) {
		send_sms_page(get_number_from_name($sSpeaker), "[Invalid command]", $sSpeaker);
		return 1;
	}

	return 0;
}


sub get_a_room() {
	my $iEmptyRoom = -1;
	while (defined $g_hRoomExpirations{++$iEmptyRoom}) { 1; }
	return $iEmptyRoom;
}



sub combine_rooms($$) {		# ('Rick', 'Sean') i.e. Rick mentions Sean and wants to pull him in
	my $sSpeaker = shift;	# can be a person's name or room number
	my $sMention = shift;
	my $iDestinationRoom;

	# were we given a room number instead of a speaker name?
	if ($sSpeaker =~ /^\d+/) {
		$iDestinationRoom = $sSpeaker;
	}
	else {
		# where are we moving people TO?
		if (defined $g_hPeoplesRooms{$sSpeaker}) {
			$iDestinationRoom = $g_hPeoplesRooms{$sSpeaker};
		}
		else {
			# the speaker wasn't in a room at all - find an empty one to stick them in
			$iDestinationRoom = $g_hPeoplesRooms{$sSpeaker} = get_a_room();
		}
	}

	syslog(LOG_DEBUG, "combine_rooms($sSpeaker, $sMention): dest=$iDestinationRoom") if (DEBUG_LEVEL > 1);

	# let's figure out where the mentioned person is
	# if they're already in the right room, it's a no-op
	return if (defined $g_hPeoplesRooms{$sMention} && ($g_hPeoplesRooms{$sMention} == $iDestinationRoom));	

	# are they part of an existing conversation with other people? (i.e. in a different room)
	if (defined $g_hPeoplesRooms{$sMention}) {
		my $iSourceRoom = $g_hPeoplesRooms{$sMention};

		# if so then we have to move every person that was in that other room with them
		foreach my $sPerson (keys %g_hPeoplesRooms) {
			if ($g_hPeoplesRooms{$sPerson} == $iSourceRoom) {
				$g_hPeoplesRooms{$sPerson} = $iDestinationRoom;
				syslog(LOG_DEBUG, " - combine_rooms, dragging $sPerson to $iDestinationRoom") if (DEBUG_LEVEL > 1);
			}
		}

		# iSourceRoom is now empty; let's get rid of it
		syslog(LOG_DEBUG, " - combine_rooms, room $iSourceRoom is empty;  deleting");
		delete_room($iSourceRoom);
	}
	else {
		syslog(LOG_DEBUG, " - combine_rooms, basic add to $iDestinationRoom") if (DEBUG_LEVEL > 1);
		# they weren't already part of a conversation so let's just add them to
		# the correct room and note that they need to be notified of a room entry
		$g_hPeoplesRooms{$sMention} = $iDestinationRoom;
	}

	# everyone that's now in the destination room --whether we just pulled them in or they
	# were previously there-- needs to be notified of who's been added
	foreach my $sPerson (keys %g_hPeoplesRooms) {
		$g_hPendingNotifies{$sPerson} = 1 if ($g_hPeoplesRooms{$sPerson} == $iDestinationRoom);
	}
}


sub process_mentions($$);
sub process_mentions($$) {
	my $sSpeaker = shift;
	my $sMessage = shift;
	my $sAt = $CFGbRequireAtForNames ? '\@' : '\b';

	foreach my $sGroup (keys %hStaff) {

		# look for any alias mentions
		if (defined($hStaff{$sGroup}{alias}) && ($sMessage =~ /$sAt($sGroup)\b/i)) {
			my $sOrigMsg = $sMessage;
			my $sAlias = $hStaff{$sGroup}{alias};

			if ($sAlias !~ /$sAt($sGroup)\b/i) {
				$sMessage =~ s/$sAt($sGroup)\b/$sAlias/gi;
				syslog(LOG_DEBUG, "mention found (alias): $sGroup - interpolating");
				process_mentions($sSpeaker, $sMessage);
				$sMessage = $sOrigMsg;
			}
			else {
				syslog(LOG_INFO, "Self-referencing alias found ($sAlias); ignoring");
			}
		}

		next unless defined($hStaff{$sGroup}{members});

		# look for any group mentions - we have to loop through them one by one in case multiple are mentioned
		if ($sMessage =~ /$sAt($sGroup)\b/i) {
			syslog(LOG_DEBUG, "mention found (group): $sGroup");

			# for any group mention we have to process each person in the group
			foreach my $sPerson (keys %{$hStaff{$sGroup}{members}}) {
				$sPerson =~ s/([^|]+).*/$1/;

				unless (defined $g_hVacationDays{$sPerson}) {
					# for each group member we want to see if they're in an existing room/conversation & if so
					# pull *everyone* from that room (the group member & everyone they're talking to) into the
					# original sSpeaker's room
					combine_rooms($sSpeaker, $sPerson);
				}
				else {
					syslog(LOG_INFO, "excluding $sPerson from $sGroup due to vacation - " . $g_hVacationDays{$sPerson});
				}
			}
		}

		# look for name mentions - we have to loop through them one by one in case multiple are mentioned
		foreach my $sPerson (keys %{$hStaff{$sGroup}{members}}) {
			if ($sMessage =~ /$sAt($sPerson)\b/i) {
				syslog(LOG_DEBUG, "mention found (member): $sPerson");
				$sPerson =~ s/([^|]+).*/$1/;
				combine_rooms($sSpeaker, $sPerson);
			}
		}

		# look for escalation tag mentions
		if (defined $hStaff{$sGroup}{escalation}{tag}) {
			my $sTag = $hStaff{$sGroup}{escalation}{tag};

			if ($sMessage =~ /$sAt($sTag)\b/i) {
				my $iCount = 0;
				my $sOnCallPerson;

				# if a tag results in an oncall person that's on vacation, let's try
				# two more times, moving the oncall schedule out a week each time
				# if the same person is configured on call for 3 weeks in a row (while
				# on vacation), well, they're going to get the page anyway
				do {
					$sOnCallPerson = get_oncall_name($sGroup, $iCount * 7);
				} while (defined($g_hVacationDays{$sOnCallPerson}) && ++$iCount < 3);

				syslog(LOG_DEBUG, "mention found (tag): $sTag [->$sOnCallPerson]");
				combine_rooms($sSpeaker, $sOnCallPerson);
			}
		}
	}
}



sub room_status(;$) {
	my $iTargetRoom = shift; 
	my $sFullResult = '';

	foreach my $iRoom (sort keys %g_hRoomExpirations) {
		next if ($iTargetRoom > -1 && ($iRoom != $iTargetRoom));

		my %hRemovedFromGroup;
		my %hThisRoomByGroup;

		my $sThisRoom = '';
		foreach my $sPerson (sort keys %g_hPeoplesRooms) {
			if (($g_hPeoplesRooms{$sPerson} == $iRoom) && ($sPerson ne 'nagios')) {
				$sThisRoom .= (length($sThisRoom) ? ', ' : '') . $sPerson;

				my $sThisPersonsGroup = get_members_group($sPerson);
				$hRemovedFromGroup{$sThisPersonsGroup}++;
				$hThisRoomByGroup{$sThisPersonsGroup}{$sPerson} = 1;
			}
		}

		my @aRoomOccupants = ();
		foreach my $sGroup (keys %hThisRoomByGroup) {
			if ($hRemovedFromGroup{$sGroup} == keys %{$hStaff{$sGroup}{members}}) {
				push(@aRoomOccupants, $sGroup);
			}
			else {
				foreach my $sPerson (keys %{$hThisRoomByGroup{$sGroup}}) {
					push(@aRoomOccupants, $sPerson);
				}
			}
		}
	
		$sFullResult .= (length($sFullResult) ? "\n" : '') . ($iTargetRoom > -1 ? '' : "Room $iRoom: ") . join(', ', sort @aRoomOccupants);
	}

	return (length($sFullResult) ? $sFullResult : 'no rooms / no conversations');
}



sub save_state($) {
	my $sFullSave = shift;

	unless ($sFullSave) {
		%g_hTimerForRoom = ();
		%g_hPeoplesRooms = ();
		%g_hRoomExpirations = ();
		%g_hRoomHistory = ();
	}

	my $SilentState = freeze(%g_hSilentRecovery);
	my $VacaState = freeze(%g_hVacationDays);
	my $TimerForRoom = freeze(%g_hTimerForRoom);
	my $PeoplesRooms = freeze(%g_hPeoplesRooms);
	my $RoomExpirations = freeze(%g_hRoomExpirations);
	my $RoomHistory = freeze(%g_hRoomHistory);

	if (open(STATE, ">/tmp/$g_sAppName.state")) {
		print STATE $SilentState . "\n";
		print STATE $VacaState . "\n";
		print STATE $g_iMetricDay . "\n";
		print STATE $g_iMetricCount . "\n";
		print STATE $TimerForRoom . "\n";
		print STATE $PeoplesRooms . "\n";
		print STATE $RoomExpirations . "\n";
		print STATE $RoomHistory . "\n";
		close(STATE);
	}
}



sub restore_state() {
	if (open(STATE, "/tmp/$g_sAppName.state")) {
		my $SilentState = <STATE>;
		my $VacaState = <STATE>;
		my $MetricDay = <STATE>;
		my $MetricCount = <STATE>;
		my $TimerForRoom = <STATE>;
		my $PeoplesRooms = <STATE>;
		my $RoomExpirations = <STATE>;
		my $RoomHistory = <STATE>;
		close(STATE);
		chomp($SilentState);
		chomp($VacaState);
		chomp($MetricDay);
		chomp($MetricCount);
		chomp($TimerForRoom);
		chomp($PeoplesRooms);
		chomp($RoomExpirations);
		chomp($RoomHistory);

		%g_hSilentRecovery = thaw($SilentState);
		%g_hVacationDays = thaw($VacaState);
		$g_iMetricDay = $MetricDay;
		$g_iMetricCount = $MetricCount;
		%g_hTimerForRoom = thaw($TimerForRoom);
		%g_hPeoplesRooms = thaw($PeoplesRooms);
		%g_hRoomExpirations = thaw($RoomExpirations);
		%g_hRoomHistory = thaw($RoomHistory);

		syslog(LOG_INFO, "successfully restored state");
	}
}



sub silence_status() {
	my $sResult = '';

	foreach my $sPerson (sort keys %g_hSilentRecovery) {
		$sResult .= (length($sResult) ? ', ' : '') . "$sPerson: " . $g_hSilentRecovery{$sPerson};
	}

	return $sResult;
}



sub vacation_status() {
	my $sResult = '';

	foreach my $sPerson (sort keys %g_hVacationDays) {
		$sResult .= (length($sResult) ? ",\n" : '') . "$sPerson: " . $g_hVacationDays{$sPerson};
	}

	return (length($sResult) ? "Vaca Days:\n$sResult" : "");
}



sub strip_hidden_aliases($$) {
	my $sMessage = shift;
	my $sCompressedMessage = shift;

	my $sAt = $CFGbRequireAtForNames ? '\@' : '\b';

	foreach my $sGroup (keys %hStaff) {

		if (defined($hStaff{$sGroup}{alias}) && defined($hStaff{$sGroup}{hidden})) {

			if ($sMessage =~ /$sAt($sGroup)\b/i) {
				$sMessage =~ s/$sAt($sGroup)\b//gi;
				syslog(LOG_INFO, "redacting hidden alias $sGroup");
			}
			elsif ($sCompressedMessage =~ /$sAt($sGroup)\b/i) {
				$sCompressedMessage =~ s/$sAt($sGroup)\b//gi;
				$sCompressedMessage =~ s/\s{2,}/ /g;
				$sMessage = $sCompressedMessage;
				syslog(LOG_INFO, "redacting hidden compressed alias $sGroup");
				# the SMS gateway inserts \n's at random points between words.  if that
				# falls in the middle of the word we're looking for we won't find it.
				# so we also check in the compressed version just to be sure.  if found
				# there we'll lose the \n formatting.  oh well.
			}
		}
	}

	return $sMessage;
}



sub expire_rooms() {
	my $iNow = time();

	foreach my $iRoom (keys %g_hRoomExpirations) {

		# find expired rooms
		if ($g_hRoomExpirations{$iRoom} < $iNow) {
			syslog(LOG_INFO, "expiring room $iRoom");

			delete_room($iRoom);

			# find everyone in the expired room and kick them out
			foreach my $sPerson (keys %g_hPeoplesRooms) {
				if ($g_hPeoplesRooms{$sPerson} == $iRoom) {
					delete $g_hPeoplesRooms{$sPerson};
				}
			}
			
		}
	}
}



sub send_sms_page($$;$) {
	my $iCellNumber = shift;
	my $sMessage = shift;
    my $sSpeaker = shift || '0';
	my $tBrowser = LWP::UserAgent->new;
	my $iNow = time();
	use constant THROTTLE_PAGES => 5;

	unless ($iCellNumber) {
		syslog(LOG_INFO, "Skipping send to blank recipient (no cell number)");
		return;
	}

	$sMessage = substr($sMessage, 0, 160);
	$sMessage =~ s/\s{2,}/ /g;
	my $sCompressedMessage = $sMessage;
	$sCompressedMessage =~ s/\n//g;

	if (($sSpeaker eq 'nagios') || ($sSpeaker =~ /^\d+$/)) {   # /\d+/ is an escalation firing

		# FILTER:  Recovery & Load
		if ($g_iRecoverySnoozeTime && ($g_iRecoverySnoozeTime > $iNow) && ($sCompressedMessage =~ /(^([-+!]{0,1}RECOVERY)|(\[Broadcast mode)|(\[Audience is now))|(System Load)/)) {
			syslog(LOG_INFO, "LOAD|RECOVERY SNOOZED ($iCellNumber) : $sMessage");
			return;
		}
		elsif ($g_iRecoverySnoozeTime && ($g_iRecoverySnoozeTime <= $iNow)) {
			syslog(LOG_INFO, "RecoverySnoozeTime expired ($g_iRecoverySnoozeTime)");
			$g_iRecoverySnoozeTime = 0;
		}

		# FILTER:  All Nagios
		if ($g_iNagiosSnoozeTime && ($g_iNagiosSnoozeTime > $iNow)) {
			syslog(LOG_INFO, "NAGIOS SNOOZED ($iCellNumber): $sMessage");
			return;
		}
		elsif ($g_iNagiosSnoozeTime) {
			syslog(LOG_INFO, "NagiosSnoozeTime expired ($g_iNagiosSnoozeTime)");
		}
		$g_iNagiosSnoozeTime = 0;

		# FILTER:  Regex
		if ($g_sRegexBlock && ($g_iRegexBlockExpire > $iNow)) {

			if ($sCompressedMessage =~ /($g_sRegexBlock)|(\[Broadcast mode)|(\[Audience is now)/i) {
				syslog(LOG_INFO, "PAGE BLOCKED via /$g_sRegexBlock/ ($iCellNumber): $sMessage");
				return;
			}
		}	
		elsif ($g_sRegexBlock) {
			syslog(LOG_INFO, "Regex Block expired (/$g_sRegexBlock/)");
			$g_sRegexBlock = '';
			$g_iRegexBlockExpire = 0;
		}

		# FILTER:  Rate Throttling
		if ((defined $g_hThrottleInfo{$iCellNumber}) && ($g_hThrottleInfo{$iCellNumber} =~ /(\d+)\/(\d+)/)) {
			my $iCount = $1;
			my $iLastTime = $2;

			if ($iNow - $iLastTime > 60) {
				$g_hThrottleInfo{$iCellNumber} = '1/' . $iNow;
			}
			else {
				$g_hThrottleInfo{$iCellNumber} = $iCount+1 . '/' . $iNow;

				if ($iCount > THROTTLE_PAGES - 1) {
					syslog(LOG_INFO, "PAGE THROTTLED ($iCellNumber): $sMessage");
					return;
				}
				elsif ($iCount == THROTTLE_PAGES - 1) {
					$sMessage = 'Throttled::' . $sMessage;
				}
			}
		}
		else {
			$g_hThrottleInfo{$iCellNumber} = '1/' . $iNow;
		}
	}

	if (length($sMessage) < 158) {
		$sMessage .= ' [' . random_string('s') . ']'; 
	}
	elsif (length($sMessage) < 160) {
		$sMessage .= random_string('s');
	}
	else {
		substr($sMessage, 159, 1) = random_string('s');
	}

	if (TEST_RUN) {
		syslog(LOG_INFO, "FAKE PAGE [$sSpeaker] ($iCellNumber): $sMessage");
		return;
	}

	# here we do an HTTP POST to signalhq.com, our vendor that lets us bypass cell companies'
	# spam filters to get our SMS messages to cell phones
	$tBrowser->timeout(10);
	my $tResponse = $tBrowser->post('http://app.signalhq.com/messages/send_individual_message',
		[
			'a' => $CFGsSignalA,
			'c' => $CFGsSignalCampaign,
			'm' => $sMessage,
			'mdn' => $iCellNumber,
		]);
	syslog(LOG_INFO, "PAGE [$sSpeaker:" . $tResponse->is_success . "] ($iCellNumber): $sMessage");
	++$g_iMetricCount;

	unless ($tResponse->is_success) {
		if (open(MAIL, "| /usr/sbin/sendmail $CFGsFallbackEmail")) {
			print MAIL "pagingd can't send via signalhq.com!";
			close(MAIL);
		}
	}
}



sub process_notifies($;$) {
	my $sSpeaker = shift;  		# can be a person's name or room number
	my $sExtraMessage = shift;
	my $bSilentMode = 0;

	if ((defined $sExtraMessage) && ($sExtraMessage eq '*')) {
		undef($sExtraMessage);
		$bSilentMode = 1;
	}

	# figure out who's in the room with the speaker
	my $sAudience = room_status(($sSpeaker =~ /^\d+/) ? $sSpeaker : $g_hPeoplesRooms{$sSpeaker});

	# tell everyone in the notify list who's in the room
	foreach my $sPerson (keys %g_hPendingNotifies) {
		delete $g_hPendingNotifies{$sPerson};
		next if ($sPerson eq 'nagios');

		my $sBroadcast = defined ($g_hBroadcastRoomOwner{$g_hPeoplesRooms{$sSpeaker}}) ? "[Broadcast mode: replies only go to " . $g_hBroadcastRoomOwner{$g_hPeoplesRooms{$sSpeaker}} . "]\n" : '';

		unless ($bSilentMode && (defined $g_hSilentRecovery{$sPerson})) {

			# send the audience update
			send_sms_page(get_number_from_name($sPerson), "${sBroadcast}[Audience is now $sAudience]" . ((defined $sExtraMessage) ? " $sExtraMessage" : ''), $sSpeaker);

			# look for auto replies we have to send out
			foreach my $sAutoReplyPerson (keys %g_hAutoReply) {

				if ($g_hAutoReply{$sAutoReplyPerson}{expire} > time()) {
					send_sms_page(get_number_from_name($sPerson), "[Auto] $sAutoReplyPerson: " . $g_hAutoReply{$sAutoReplyPerson}{reply}, $sSpeaker)
						unless ($sBroadcast && ($sPerson ne $g_hBroadcastRoomOwner{$g_hPeoplesRooms{$sSpeaker}}));
				}
				else {
					delete($g_hAutoReply{$sAutoReplyPerson});
					syslog(LOG_INFO, "Auto reply for $sAutoReplyPerson expired.");
				}
			}
		}
	}
}



sub process_pages($$) {
	my $sSpeaker = shift;	# can be a person or a room number
	my $sMessage = shift;
	my $iRoom = ($sSpeaker =~ /^\d+/) ? $sSpeaker : $g_hPeoplesRooms{$sSpeaker};
	my $iRecips = 0;

	if ($iRoom =~ /^\d+/ || $sSpeaker eq 'emergency') {
		$iRoom = $g_hPeoplesRooms{get_oncall_name($CFGsEmergencyGroup)} if ($sSpeaker eq 'emergency');

		foreach my $sPerson (keys %g_hPeoplesRooms) {
			next if (($sPerson eq 'nagios') || ($sPerson eq 'emergency'));

			if ($g_hPeoplesRooms{$sPerson} == $iRoom) {
				next if ($sPerson eq $sSpeaker);							# it's my own message

				next if (defined($g_hBroadcastRoomOwner{$iRoom})  			# it's a broadcast only room
						&& ($g_hBroadcastRoomOwner{$iRoom} ne $sPerson) 	# this outgoing copy isn't destined to the broadcast owner
						&& ($g_hBroadcastRoomOwner{$iRoom} ne $sSpeaker));	# it isn't the broadcast owner speaking

				++$iRecips;

				if (($sMessage =~ /^RECOVERY/) && (defined $g_hSilentRecovery{$sPerson})) {
					# we don't decrement if it's set to -1 as that's a permanent setting
					$g_hSilentRecovery{$sPerson}-- if ($g_hSilentRecovery{$sPerson} > 0);
					syslog(LOG_DEBUG, "process_page($sSpeaker,x): Silenced RECOVERY for $sPerson (remaining " . $g_hSilentRecovery{$sPerson} . ")");
				}
				else {
					send_sms_page(get_number_from_name($sPerson), $sMessage, $sSpeaker)
				}
			}
		}
	}

	my $bHandled = 0;

	if ($sSpeaker && ($sSpeaker ne 'nagios') && ($sSpeaker ne 'emergency')) {
    	# loop through all rooms with escalation timers on them
    	foreach my $iEscalationRoomNumber (keys %g_hTimerForRoom) {

    		# if the reply is from the person in this escalation room
    		# (probably the on call person probably saying "I got it!")
    		if ($g_hPeoplesRooms{$sSpeaker} == $iEscalationRoomNumber) {
    			syslog(LOG_INFO, "Escalation canceled due to reply from $sSpeaker (room $iEscalationRoomNumber)");
    			delete($g_hTimerForRoom{$iEscalationRoomNumber});

				my $sSpeakersGroup = get_members_group($sSpeaker);
				if (defined $hStaff{$sSpeakersGroup}{escalation}{cancel_msg}) {
    				send_sms_page(get_number_from_name($sSpeaker), $hStaff{$sSpeakersGroup}{escalation}{cancel_msg}, $sSpeaker);
				}

    			$bHandled = 1;
    			last;
    		}
    	}
	}

	# if no pages were sent out and the reply isn't from a person in an escalation timer room
	if (!$iRecips && !$bHandled) {
			if ($sSpeaker eq 'nagios') {
				syslog(LOG_INFO, "nagios sent a message with no recipients;  page ignored");
			}
			else {
				send_sms_page(get_number_from_name($sSpeaker), 
					"[There's no one in this conversation other than you.  Name a person or group to include someone else.] ", $sSpeaker);
			}
	}
}



sub daemon_startup() {
	$g_tDaemon = Proc::Daemon->new(
		work_dir => '/tmp',
		pid_file => $g_sPIDFile,
	);

	$g_iDaemonPid = $g_tDaemon->Init;
	daemon_main() unless $g_iDaemonPid;
	# else we're in the client and just return from here
}


sub daemon_main() {
	syslog(LOG_INFO, 'daemon starting in ' . (TEST_RUN ? 'TEST MODE - no pages will be sent' : 'live mode'));
	unlink($g_sSocketPath);
	restore_state();

	# open the main server-side listening socket
	$g_tListenerSocket = IO::Socket::UNIX->new(
		Type   => SOCK_STREAM,
		Local  => $g_sSocketPath,
		Listen => 50,
	) or die("Can't create server socket: $!\n");

	# create a list of file handles for reading, add our listening socket 
	my ($tReadHandles) = new IO::Select();
	$tReadHandles->add($g_tListenerSocket);

	# the life of a daemon - listen for socket connections all day
	while (1) {

		# sleep at most 30 seconds waiting for a socket connection
		my ($tReadSet) = IO::Select->select($tReadHandles, undef, undef, 30);

		expire_rooms();
		daily_housekeeping();

		# see if we woke up for a socket vs the 30 second timeout
		foreach my $tRH (@$tReadSet) {
			my $tSocket = $g_tListenerSocket->accept() or die("Can't accept connection: $!\n");
			my $sSenderCallerId = '';
			my $sMessage = '';
			my $sSpeaker = '';

			while (my $sLine = <$tSocket>) {
				chomp($sLine);

				if ($sLine =~ /FF:(\S+):FF/) {
					$sSenderCallerId = $1;

					$sSpeaker = get_name_from_number($sSenderCallerId);
					next;
				}

				$sMessage .= (length($sMessage) ? "\n" : '') . $sLine;
			}

			if ($sSpeaker =~ /^\d/) {
				syslog(LOG_INFO, "Page from unknown user ($sSpeaker);  dropping [$sMessage]");
			}
			elsif ($sSpeaker =~ /^maint:(.+)/i) {
				my $sMaintWorkers = $1;
				$sSpeaker = 'nagios';

				if ($g_iMaintenanceRoomNumber > -1) {
					combine_rooms($g_iMaintenanceRoomNumber, 'nagios') 
				}
				else {
        			$g_iMaintenanceRoomNumber = $g_hPeoplesRooms{'nagios'} = get_a_room();
        			$g_hRoomExpirations{$g_iMaintenanceRoomNumber} = time() + 5400;
				}
				process_mentions($g_iMaintenanceRoomNumber, $sMaintWorkers);

				$g_iMaintenanceRoomNumber = $g_hPeoplesRooms{$sSpeaker};
				$g_hRoomExpirations{$g_iMaintenanceRoomNumber} = time() + 5400;

				foreach (keys %g_hPeoplesRooms) {
					if ($g_hPeoplesRooms{$_} == $g_iMaintenanceRoomNumber) {
						next if ($_ eq 'nagios');

						send_sms_page(get_number_from_name($_), "[Cron has designated this a maintenance window room]", 'cron');
					}
				}
				process_notifies($g_iMaintenanceRoomNumber);
			}
			else {
				syslog(LOG_INFO, "MSG [$sSpeaker]: \"$sMessage\"");
				my $sCompressedMessage = $sMessage;
				$sCompressedMessage =~ s/\n//g;

				# $sSpeaker == 'emergency' is here to avoid the call to handle_paging_commands() on emergency pages;
				# otherwise those emergency pages might get flagged with an ambiguous name & get dropped
				if (($sSpeaker eq 'emergency') || !handle_paging_commands($sSpeaker, $sCompressedMessage)) {
					my $sSilenceStatus = silence_status();
					my $sVacationStatus = vacation_status();
					syslog(LOG_DEBUG, "CSG: $sCompressedMessage") if (DEBUG_LEVEL);
					syslog(LOG_DEBUG, "PRE: " . room_status(-1)) if (DEBUG_LEVEL > 1);
					syslog(LOG_DEBUG, "Silenced RECOVERY set: $sSilenceStatus") if ($sSilenceStatus);
					syslog(LOG_DEBUG, "Vacation days set: $sVacationStatus") if ($sVacationStatus);

					# process all group/name mentions for non emergency pages
					# (also puts the speaker in a room if they don't already have one)
					if ($sSpeaker ne 'emergency') {

						# leading bang means we take the message literally;  don't look for name references
						if ($sMessage =~ /^\!/) {
							$sMessage =~ s/^\!//;
						}
						else {
							if (($g_iMaintenanceRoomNumber == -1) || ($sCompressedMessage !~ /^(PROBLEM|RECOVERY)/)) {
								process_mentions($sSpeaker, $sCompressedMessage);
								$sMessage = strip_hidden_aliases($sMessage, $sCompressedMessage);
							}
						}

						$sMessage =~ s/^\^//;
					}
					else {
						# emergency page - put the On Call person in a room and set a timer for their reply
						my $iEmergencyRoom;
						my $sOnCallPerson = get_oncall_name($CFGsEmergencyGroup);
						if (defined $g_hPeoplesRooms{$sOnCallPerson}) {
							$iEmergencyRoom = $g_hPeoplesRooms{$sOnCallPerson};
						}
						else {
							$g_hPeoplesRooms{$sOnCallPerson} = $iEmergencyRoom = get_a_room();
						}
						my $iEscTime = defined($hStaff{$CFGsEmergencyGroup}{escalation}{timer}) ? $hStaff{$CFGsEmergencyGroup}{escalation}{timer} : 120;
						$g_hTimerForRoom{$iEmergencyRoom} = time() + $iEscTime - 61;

						my @aHistory = ($sMessage);
						$g_hRoomHistory{$iEmergencyRoom} = \@aHistory;
						syslog(LOG_DEBUG, "Setting Emergency escalation timer on room $iEmergencyRoom to " . $g_hTimerForRoom{$iEmergencyRoom});

						my $iTicketNumber = TEST_RUN ? 40314 : create_911_rt_ticket($sMessage);
						send_emergency_email($iTicketNumber, $sMessage) unless TEST_RUN;  
						$g_hTicketForRoom{$iEmergencyRoom} = $iTicketNumber;
					}

					# if the page is from nagios and it didn't result in any notifications (i.e. it didn't mention
					# any recipients by name or group), then it's destined for nowhere;  we can bail.
					if (($sSpeaker eq 'nagios' ) && !defined($g_hPeoplesRooms{'nagios'})) { 
						syslog(LOG_INFO, "nagios sent a message with no recipients; page ignored");
					}
					else {
						# below we setup room details, including expiriation time & history
						# we don't want to do this unless there's a conversation in progress
						if (defined $g_hPeoplesRooms{$sSpeaker} || $sSpeaker eq 'emergency' || $sSpeaker eq 'nagios') {
							my $bSkipNotifies = 0;

							my $sEscalationTags = '';
							foreach my $sGroup (keys %hStaff) {
								$sEscalationTags .= (length($sEscalationTags) ? '|' : '') . $hStaff{$sGroup}{escalation}{tag} if (defined $hStaff{$sGroup}{escalation}{tag});
							}
							my $sAt = $CFGbRequireAtForNames ? '\@' : '\b';

							# special case:  if nagios pages oncall AND the oncall person isn't already in a room
							# with someone else, then set an escalation timer for their room
							if (($sSpeaker eq 'nagios') && ($sMessage =~ /$sAt($sEscalationTags)\b/i)) {
								my $iParticipants = 0;
								foreach my $iTestRoom (values %g_hPeoplesRooms) {
									$iParticipants++ if ($iTestRoom == $g_hPeoplesRooms{'nagios'});
									last if ($iParticipants > 2);
								}

								# consider setting an escalation timer if the room only has the on call person & nagios
								unless ($iParticipants > 2) {

									if ($sMessage !~ /^RECOVERY/) {
										# nagios may send a second copy of the PROBLEM page before we've escalated
										# and we don't want that to reset our escalation timer.  so check if a timer
										# was previously set before setting a new one
										if (!defined $g_hTimerForRoom{$g_hPeoplesRooms{'nagios'}}) {

											foreach my $sStaffGroup (keys %hStaff) {
												if (defined $hStaff{$sStaffGroup}{escalation} && defined $hStaff{$sStaffGroup}{escalation}{tag}) {
													my $sTag = $hStaff{$sStaffGroup}{escalation}{tag};

													if ($sMessage =~ /$sAt$sTag\b/i) {
														$bSkipNotifies = 1;
														$sMessage = '+' . $sMessage;
														$g_hTimerForRoom{$g_hPeoplesRooms{'nagios'}} = time() + $hStaff{$sStaffGroup}{escalation}{timer} - 61;
														syslog(LOG_INFO, 'Setting escalation timer on room ' . $g_hPeoplesRooms{'nagios'} . ' to ' . $g_hTimerForRoom{$g_hPeoplesRooms{'nagios'}});
													}
												}
											}
										}
									}
									# Else this is a recovery page;  but is there an escalaltion timer in effect?
									elsif (defined $g_hTimerForRoom{$g_hPeoplesRooms{'nagios'}}) {  
										$sMessage = '-' . $sMessage;
										delete($g_hTimerForRoom{$g_hPeoplesRooms{'nagios'}});
										syslog(LOG_INFO, 'Escalation canceled due to RECOVERY page (room ' . $g_hPeoplesRooms{'nagios'} . ')');
										$bSkipNotifies = 1;
									}
									else {
										# recovery page has come through but there's no escalation timer going.  so we'll
										# just send out this recovery as usual.  but let's nix the audience update.
										# this is safe becauase nagios isn't likely to be changing the audience between problem
										# & recovery.  so either the audience didn't change anyway (nothing to notify) or we're
										# going from a non-existent chat room to one being created just for this recovery message.
										# either way, we can skip this update.
										$bSkipNotifies = 1;
									}
								}
							}

							# set/update the expiration time on the [possibly newly created] room
							$g_hRoomExpirations{$g_hPeoplesRooms{($sSpeaker eq 'emergency') ? get_oncall_name($CFGsEmergencyGroup) : $sSpeaker}} = time() + 5400;    # 90 minutes from now

							my $sOrigMessage = $sMessage;
							$sMessage = "$sSpeaker: $sMessage" unless (($sSpeaker eq 'nagios') || ($sSpeaker eq 'emergency'));

							# add the message to the room's history array
							if (defined $g_hPeoplesRooms{$sSpeaker}) { 	 # always true except for an emergency message
								if (defined $g_hRoomHistory{$g_hPeoplesRooms{$sSpeaker}}) {
									push(@{$g_hRoomHistory{$g_hPeoplesRooms{$sSpeaker}}}, $sMessage);
								}
								else {
									my @aHistory = ($sMessage);
									$g_hRoomHistory{$g_hPeoplesRooms{$sSpeaker}} = \@aHistory;
								}
							}

							syslog(LOG_DEBUG, "Ticket for room " . $g_hPeoplesRooms{$sSpeaker} . ": " . $g_hTicketForRoom{$g_hPeoplesRooms{$sSpeaker}}) if (defined $g_hTicketForRoom{$g_hPeoplesRooms{$sSpeaker}});
							rt_command("comment -m - " . $g_hTicketForRoom{$g_hPeoplesRooms{$sSpeaker}}, $sMessage)
								if ((defined $g_hTicketForRoom{$g_hPeoplesRooms{$sSpeaker}}) && ($sOrigMessage !~ /^\!/));

							syslog(LOG_DEBUG, "POST: " . room_status(-1)) if (DEBUG_LEVEL > 1);
							syslog(LOG_INFO, "Notify: " . join(', ', sort keys(%g_hPendingNotifies)));

							foreach my $iRoom (keys %g_hRoomExpirations) {
								syslog(LOG_DEBUG, "Room $iRoom history: " . get_history($iRoom)) if (DEBUG_LEVEL > 1);
							}

							foreach my $iRoom (keys %g_hTicketForRoom) {
								syslog(LOG_DEBUG, "Ticket for room $iRoom: " . $g_hTicketForRoom{$iRoom}) if (DEBUG_LEVEL > 1);
							}

							process_pages($sSpeaker, $sMessage);

							if ($g_iInitBroadcastOwner) {
								$g_hBroadcastRoomOwner{$g_hPeoplesRooms{$sSpeaker}} = $g_iInitBroadcastOwner;
								syslog(LOG_INFO, "Setting broadcast owner for room " . $g_hPeoplesRooms{$sSpeaker} . " = " . $g_iInitBroadcastOwner);
							}

							if (!$bSkipNotifies) {
								if ($sMessage =~ /^RECOVERY/) {
									process_notifies($sSpeaker, '*'); 
								}
								else {
									process_notifies($sSpeaker); 
								}
							}
							else {
								# we still have to delete the pending notifications
								foreach my $sPerson (keys %g_hPendingNotifies) {
									delete $g_hPendingNotifies{$sPerson};
								}
							}

							foreach my $sPerson (keys %g_hSilentRecovery) {
								if ($g_hSilentRecovery{$sPerson} == 0) {
									delete($g_hSilentRecovery{$sPerson}); 
									syslog(LOG_INFO, "Silent request count reached for $sPerson;  restoring RECOVERY pages");
								}
							}
						}
						else {
							send_sms_page(get_number_from_name($sSpeaker),
                    			"[There's no one in this conversation other than you.  Name a person or group to include someone else.]", $sSpeaker);
						}
					}
				}
			}
			close($tSocket);
			$g_iInitBroadcastOwner = 0;
		}

		# the daemon hits this loop at least every 30 seconds - sooner if there's a socket connection
		# let's check to see if we have a room timer that's expiring and we need to escalate a page
		# this is one area where we don't have a $sSpeaker
		foreach my $iEscalationRoomNumber (keys %g_hTimerForRoom) {
			next unless ($g_hTimerForRoom{$iEscalationRoomNumber} < time());

			# if it's the initial timer that expired - let's resend the initial page & wait 1 more minute before escalating
			unless ($g_hTimerForRoom{$iEscalationRoomNumber} =~ /\./) {
				syslog(LOG_INFO, "Early escalation timer is up; resending one last time pre-escalation (room $iEscalationRoomNumber)");

				if (defined $g_hRoomHistory{$iEscalationRoomNumber}) {
                	my @aHistory = @{$g_hRoomHistory{$iEscalationRoomNumber}};
                	my $sLastPage = $aHistory[$#aHistory];
                	process_pages($iEscalationRoomNumber, $sLastPage);
				}
				$g_hTimerForRoom{$iEscalationRoomNumber} = time() + 59.1;
				next;
			}

			syslog(LOG_INFO, "Escalation timer expired for room $iEscalationRoomNumber - ESCALATING");

			foreach my $sPerson (keys %g_hPeoplesRooms) {

				if (($g_hPeoplesRooms{$sPerson} == $iEscalationRoomNumber)
					 && ($sPerson ne 'nagios') && ($sPerson ne 'emergency')) {

					# then we're going to escalate 
					my $sPersonsGroup = get_members_group($sPerson);

					if (defined $hStaff{$sPersonsGroup}{escalation}{on_expire_to}) {
						process_mentions($sPerson, $hStaff{$sPersonsGroup}{escalation}{on_expire_to});
					}
					else {
						syslog(LOG_INFO, "Escalation timer expired but there's no 'on_expire_to' list to escalate to;  ignoring");
					}

					last;
				}
			}

			# then send everything out
			if (defined $g_hRoomHistory{$iEscalationRoomNumber}) {
				my @aHistory = @{$g_hRoomHistory{$iEscalationRoomNumber}};
				my $sLastPage = $aHistory[$#aHistory];
				$sLastPage =~ s/^\+/\!/;
				process_pages($iEscalationRoomNumber, $sLastPage);
			}
			else {
				process_pages($iEscalationRoomNumber, "[An emergency page has been escalated to you but the original text is missing.  Check your email.]");
			}

			process_notifies($iEscalationRoomNumber, 'Was auto escalated');
			delete($g_hTimerForRoom{$iEscalationRoomNumber});
		}
	}

	exit;
}



sub parse_email_from_stdin() {
	my @aNewMsg;
	my $sClientCallerId = '';
	my $bInMessageBody = 0;
	my $bEmergencyEmail = 0;
	my $bQuotedPrintable = 0;

	foreach (@g_aSTDIN) {
		#syslog(LOG_DEBUG, "raw_message_line: " . $_);

		# snag & save the sender's callerid from the subject line
		if (/^Subject: sms_reply:(\d+)/) {
			$sClientCallerId = $1;
		}
		elsif (/^Subject: NPR - ER ISSUES/) {
			$bEmergencyEmail = 1;
		}

		if (/^Content-Transfer-Encoding:\s+quoted-printable/i) {
			$bQuotedPrintable = 1;
		}

		# cheap and hackishly use the callerid field to store the sender's name
		# if the input is from an email reply rather than an sms one
		if (/^From: (\S+)/ && !length($sClientCallerId)) {
			$sClientCallerId = $1;
		}

		# look for a blank line, separating headers & body
		if (/^$/) {

			# if the sender is valid and we've hit a blank line then
			# the rest of the input is valid message text
			if (length($sClientCallerId)) {
				$bInMessageBody = 1;
			}
			else {
				return 0;
			}

			next;    # skip the blank line
		}

		if ($bInMessageBody) {
			if ($bQuotedPrintable) {
				s/=(\n*)$/$1/; 
				s/=3D/=/g;
			}

			s/\&apos;/\'/g;
			push(@aNewMsg, $_);
		}
	}

	@g_aSTDIN = @aNewMsg;

	if ($bEmergencyEmail) {
		my $bFoundEmail = 0;

		foreach (@g_aSTDIN) {
			last if ($bFoundEmail && /YES/);      # bomb out once we've found the contact email if it's a streaming call (i.e. YES)

			s/^\s*(\w|\s)+:\s*(.+)/$2/;	          # drop the field names
			$bFoundEmail = 1 if (/\S\@\S+\.\S/);
		}

		$sClientCallerId = 'emergency';
	}


	return $sClientCallerId;
}


#-#  M A I N  #-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#-#

boot_syntax_check();

my $sClientCallerId = '';

if (-t STDIN) {  # no stdin
	#print "The paging app can be called in one of two ways:\n";
	#print "\t1. 'nagios' as a commandline param & message text on STDIN\n";
	#print "\t2. An email from signalhq.com on STDIN\n";
	#print "\nWith option (1) the message text is the literal page text and will be scanned for\n";
	#print "name mentions to determine the recipients.\n";
	#print "With option (2) the input is a full email message.  The headers will be discarded.  The Subject\n";
	#print "is expected to include the sender's Caller ID in a particular format, and the body will\n";
	#print "be scanned for name mentions to determine the recipients.\n";
	#exit;

	unless (defined $ARGV[0] && ($ARGV[0] =~ /maint:/i)) {
		$g_bBootOnly = 1;
	}
}
else {
	@g_aSTDIN = <STDIN>;
}

if (defined $ARGV[0]) {
	if ($ARGV[0] !~ /nagios|emergency|hup|oncall|maint/) {
		print "The only supported commandline parameter is for nagios to send pages.\n";
		print "When nagios is sending we take STDIN as literal pager text.\n";
		print "Otherwise we assume STDIN is an email to be parsed.\n";
		exit;
	}
	$sClientCallerId = $ARGV[0];
}
else {
	$sClientCallerId = parse_email_from_stdin();
}

$g_bBootOnly = 1 if (defined $ARGV[0] && $ARGV[0] eq 'hup');

if ($sClientCallerId eq 'oncall') {
	if (defined $ARGV[1]) {
		print get_oncall_schedule($ARGV[1]) . "\n";
		exit;
	}
	print "'oncall' requires a group name\n";
	exit;
}

# is the daemon alive?
my $bDaemonLives = is_daemon_alive();


# if not, spin it up
unless ($bDaemonLives) {
	daemon_startup();  # this returns in the parent/client after forking off the child/daemon
	sleep(1);
}


unless ($g_bBootOnly) {

	# here we're in the client and have something to send to the daemon
	my $tSocket = IO::Socket::UNIX->new(
		Type => SOCK_STREAM,
		Peer => $g_sSocketPath,
	) or die("Can't connect to server: $!\n");

	print $tSocket "FF:" . $sClientCallerId . ":FF\n";
	foreach (@g_aSTDIN) {
		print $tSocket $_;
	}
	close($tSocket);
}

